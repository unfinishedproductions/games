<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>P2P Pixel Swarm (Duel Mode)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- Trystero P2P Library -->
    <script type="module">
        import { joinRoom } from 'https://cdn.skypack.dev/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>

    <style>
        .font-pixel { font-family: 'VT323', monospace; letter-spacing: 0.1em; }
        
        html, body { 
            margin: 0; padding: 0; height: 100%; width: 100%; 
            overflow: hidden; background-color: #f0f0f0; color: #111;
            touch-action: none; 
        }
        
        canvas { display: block; image-rendering: pixelated; }

        #ui-layer { position: absolute; top: 1rem; right: 1rem; pointer-events: none; text-align: right; }
        
        .status-box { 
            background: #fff; 
            border: 2px solid #000; 
            box-shadow: 4px 4px 0px #000;
            padding: 10px 15px; 
            display: inline-block; 
            pointer-events: auto; 
            margin-bottom: 10px;
        }

        #fight-btn {
            background-color: #3b82f6;
            color: white;
            border: 2px solid #000;
            box-shadow: 4px 4px 0px #000;
            padding: 5px 15px;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            pointer-events: auto;
            display: none; /* Hidden by default */
            text-transform: uppercase;
        }
        #fight-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px #000; }
    </style>
</head>
<body class="font-pixel">

    <div id="ui-layer">
        <div class="status-box">
            <h1 class="text-xl uppercase border-b-2 border-black mb-1">Swarm Sync</h1>
            <p>STATUS: <span id="status-text" class="text-gray-500">INITIALIZING...</span></p>
            <p>PEERS: <span id="peer-count">0</span></p>
        </div>
        <br>
        <button id="fight-btn">FIGHT</button>
    </div>

    <canvas id="swarmCanvas"></canvas>

    <script type="module">
        // --- CONFIGURATION ---
        const LOGICAL_SIZE = 1000; 
        const NUM_PARTICLES = 400; 
        const PARTICLE_SIZE = 3; 
        const MAX_SPEED = 1.8; 
        const MAX_FORCE = 0.05; 

        // Physics
        const PERCEPTION_RADIUS = 50; 
        const SEPARATION_DISTANCE = 25; 
        const SEPARATION_FACTOR = 1.2; 
        const ALIGNMENT_FACTOR = 0.6;  
        const COHESION_FACTOR = 0.45;
        const TARGET_SEEK_FACTOR = 0.5; 
        const DENSITY_HIGH_THRESHOLD = 15;
        const DENSITY_LOW_THRESHOLD = 3;

        // Optimization
        const PERCEPTION_RADIUS_SQ = PERCEPTION_RADIUS * PERCEPTION_RADIUS;
        const SEPARATION_DISTANCE_SQ = SEPARATION_DISTANCE * SEPARATION_DISTANCE;
        const SEEK_ACTIVATION_SQ = 100 * 100;
        const COLLISION_SQ = (PARTICLE_SIZE * 2) ** 2; // Simple bounding box check

        // Seeded Random
        function sfc32(a, b, c, d) {
            return function() {
                a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
                var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21) | d; d = d + 1 | 0;
                t = t + d | 0; c = c + t | 0; return (t >>> 0) / 4294967296;
            }
        }
        const rng = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, 1337);

        // --- CLASSES ---
        class Vector {
            constructor(x, y) { this.x = x || 0; this.y = y || 0; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            magSq() { return this.x * this.x + this.y * this.y; }
            mag() { return Math.sqrt(this.magSq()); }
            normalize() {
                let m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }
            setMag(m) { return this.normalize().mult(m); }
            limit(max) {
                if (this.magSq() > max * max) { this.setMag(max); }
                return this;
            }
            set(x, y) { this.x = x; this.y = y; return this; }
        }

        class Particle {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
                this.acceleration = new Vector(0, 0);
                
                this._steer = new Vector(0,0);
                this._desired = new Vector(0,0);
                
                // Interpolation Target
                this.serverPos = new Vector(x, y);
                this.colliding = false; // Collision flag 
            }

            applyForce(force) {
                this.acceleration.add(force);
            }

            applySteerBehavior(targetX, targetY, factor) {
                this._desired.set(targetX, targetY);
                this._desired.sub(this.position);
                this._desired.setMag(MAX_SPEED);
                this._steer.set(this._desired.x, this._desired.y);
                this._steer.sub(this.velocity);
                this._steer.limit(MAX_FORCE * factor);
                this.applyForce(this._steer);
            }

            // PHYSICS LOGIC
            applyBehaviors(particles, target) {
                let sepX = 0, sepY = 0, countSep = 0;
                let aliX = 0, aliY = 0;
                let cohX = 0, cohY = 0, countCoh = 0;
                const px = this.position.x;
                const py = this.position.y;

                for (let i = 0; i < particles.length; i++) {
                    const other = particles[i];
                    if (other === this) continue;
                    const dx = px - other.position.x;
                    const dy = py - other.position.y;
                    const dSq = dx*dx + dy*dy;

                    if (dSq > 0 && dSq < PERCEPTION_RADIUS_SQ) {
                        if (dSq < SEPARATION_DISTANCE_SQ) {
                            const dist = Math.sqrt(dSq);
                            sepX += (dx / dist) / dist; 
                            sepY += (dy / dist) / dist;
                            countSep++;
                        }
                        aliX += other.velocity.x;
                        aliY += other.velocity.y;
                        cohX += other.position.x;
                        cohY += other.position.y;
                        countCoh++;
                    }
                }

                if (countSep > 0) {
                    sepX /= countSep; sepY /= countSep;
                    const sepMag = Math.sqrt(sepX*sepX + sepY*sepY);
                    if (sepMag > 0) {
                        sepX = (sepX / sepMag) * MAX_SPEED;
                        sepY = (sepY / sepMag) * MAX_SPEED;
                    }
                    let steerX = sepX - this.velocity.x;
                    let steerY = sepY - this.velocity.y;
                    const steerSq = steerX*steerX + steerY*steerY;
                    const limitSq = (MAX_FORCE * SEPARATION_FACTOR) ** 2;
                    if (steerSq > limitSq) {
                        const mult = (MAX_FORCE * SEPARATION_FACTOR) / Math.sqrt(steerSq);
                        steerX *= mult;
                        steerY *= mult;
                    }
                    this.acceleration.x += steerX;
                    this.acceleration.y += steerY;
                }

                if (countCoh > 0) {
                    aliX /= countCoh; aliY /= countCoh;
                    const aliMag = Math.sqrt(aliX*aliX + aliY*aliY);
                    if (aliMag > 0) {
                        aliX = (aliX / aliMag) * MAX_SPEED;
                        aliY = (aliY / aliMag) * MAX_SPEED;
                    }
                    let aliSteerX = aliX - this.velocity.x;
                    let aliSteerY = aliY - this.velocity.y;
                    const aliLimitSq = (MAX_FORCE * ALIGNMENT_FACTOR) ** 2;
                    if ((aliSteerX*aliSteerX + aliSteerY*aliSteerY) > aliLimitSq) {
                        const mult = (MAX_FORCE * ALIGNMENT_FACTOR) / Math.sqrt(aliSteerX*aliSteerX + aliSteerY*aliSteerY);
                        aliSteerX *= mult;
                        aliSteerY *= mult;
                    }
                    this.acceleration.x += aliSteerX;
                    this.acceleration.y += aliSteerY;

                    cohX /= countCoh; cohY /= countCoh;
                    let dynamicFactor = COHESION_FACTOR;
                    if (countCoh > DENSITY_HIGH_THRESHOLD) dynamicFactor *= 0.5;
                    else if (countCoh <= DENSITY_LOW_THRESHOLD) dynamicFactor *= 1.3;
                    this.applySteerBehavior(cohX, cohY, dynamicFactor);
                }

                const dResX = target.x - px;
                const dResY = target.y - py;
                if ((dResX*dResX + dResY*dResY) > SEEK_ACTIVATION_SQ) {
                    this.applySteerBehavior(target.x, target.y, TARGET_SEEK_FACTOR);
                }
            }

            update() {
                this.velocity.add(this.acceleration);
                this.velocity.limit(MAX_SPEED);
                this.position.add(this.velocity);
                this.acceleration.mult(0);
            }

            // VIEWER INTERPOLATION
            updateViewer() {
                const lerpFactor = 0.15; 
                this.position.x += (this.serverPos.x - this.position.x) * lerpFactor;
                this.position.y += (this.serverPos.y - this.position.y) * lerpFactor;
            }

            draw(ctx, color) {
                ctx.fillStyle = this.colliding ? '#ff0000' : color;
                ctx.fillRect(this.position.x, this.position.y, PARTICLE_SIZE, PARTICLE_SIZE);
            }
        }

        // --- ENGINE ---
        const canvas = document.getElementById('swarmCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let displayWidth, displayHeight;
        let scale = 1;
        
        // Two Swarms
        let particlesHost = []; // The original swarm (Host owned)
        let particlesViewer = []; // The duel swarm (Viewer owned)
        
        let targetHost = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 }; 
        let targetViewer = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 };

        // --- NETWORK STATE ---
        let role = 'WAITING';
        let isFighting = false; // Are we dueling?
        let peers = 0;
        let lastHeartbeat = 0;
        const myHostId = Math.floor(Math.random() * 1000000); 

        function resize() {
            displayWidth = window.innerWidth;
            displayHeight = window.innerHeight;
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            scale = Math.min(displayWidth / LOGICAL_SIZE, displayHeight / LOGICAL_SIZE);
        }

        function initSimulation() {
            resize();
            if (particlesHost.length === 0) {
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    particlesHost.push(new Particle(rng() * LOGICAL_SIZE, rng() * LOGICAL_SIZE));
                    // Initialize second swarm off-screen or same spot
                    particlesViewer.push(new Particle(rng() * LOGICAL_SIZE, rng() * LOGICAL_SIZE));
                }
            }
        }

        function animate() {
            // Draw Background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            ctx.save();
            const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
            const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Bounds
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);

            // Targets
            ctx.fillStyle = '#000000'; // Host Target
            ctx.fillRect(targetHost.x - 2, targetHost.y - 2, 4, 4);
            
            if (isFighting) {
                ctx.fillStyle = '#0000ff'; // Viewer Target
                ctx.fillRect(targetViewer.x - 2, targetViewer.y - 2, 4, 4);
            }

            // 1. UPDATE STEPS
            if (role === 'HOST') {
                // Host computes Host Swarm physics
                for (let p of particlesHost) {
                    p.applyBehaviors(particlesHost, targetHost);
                    p.update();
                    p.colliding = false; // Reset collision
                }
                // Host interpolates Viewer Swarm (from network)
                if (isFighting) {
                    for (let p of particlesViewer) {
                        p.updateViewer();
                        p.colliding = false; 
                    }
                }
            } else {
                // Viewer interpolates Host Swarm (from network)
                for (let p of particlesHost) {
                    p.updateViewer();
                    p.colliding = false;
                }
                // If fighting, Viewer computes Viewer Swarm physics
                if (isFighting) {
                    for (let p of particlesViewer) {
                        p.applyBehaviors(particlesViewer, targetViewer);
                        p.update();
                        p.colliding = false;
                    }
                }
            }

            // 2. COLLISION DETECTION (If Fighting)
            if (isFighting) {
                // Brute force check: O(N*N) - acceptable for 400x400 in JS usually
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    const pH = particlesHost[i];
                    for (let j = 0; j < NUM_PARTICLES; j++) {
                        const pV = particlesViewer[j];
                        const dx = pH.position.x - pV.position.x;
                        const dy = pH.position.y - pV.position.y;
                        if (dx*dx + dy*dy < COLLISION_SQ) {
                            pH.colliding = true;
                            pV.colliding = true;
                        }
                    }
                }
            }

            // 3. DRAW STEPS
            // Draw Host Swarm (Black, or Red if colliding)
            for (let p of particlesHost) p.draw(ctx, '#000000');
            
            // Draw Viewer Swarm (Blue, or Red if colliding)
            if (isFighting) {
                for (let p of particlesViewer) p.draw(ctx, '#0000ff');
            }

            ctx.restore();
            requestAnimationFrame(animate);
        }

        // --- NETWORKING ---
        const TRANSMISSION_RATE = 12; 

        function setupNetwork() {
            const room = window.joinRoom({ appId: 'pixel_swarm_sim_v3_fixed' }, 'swarm_room_main');
            
            const [sendHeartbeat, getHeartbeat] = room.makeAction('hb');
            
            // Host Swarm Data
            const [sendSwarmData, getSwarmData] = room.makeAction('sd'); 
            
            // Viewer Swarm Data (Opponent)
            const [sendSwarmData2, getSwarmData2] = room.makeAction('sd2'); 

            // Fight Negotiation
            const [sendFightReq, getFightReq] = room.makeAction('reqFight');
            const [sendFightAns, getFightAns] = room.makeAction('ansFight');

            room.onPeerJoin(() => { peers++; updateStatus(); });
            room.onPeerLeave(() => { peers--; updateStatus(); });

            // FIGHT LOGIC
            const fightBtn = document.getElementById('fight-btn');
            
            fightBtn.onclick = () => {
                if (role === 'VIEWER') {
                    sendFightReq('FIGHT ME');
                    fightBtn.innerText = "WAITING...";
                    fightBtn.disabled = true;
                }
            };

            // Host receives Fight Request
            getFightReq((data, peerId) => {
                if (role === 'HOST' && !isFighting) {
                    if (confirm("Peer requesting DUEL. Accept?")) {
                        isFighting = true;
                        sendFightAns(true);
                    } else {
                        sendFightAns(false);
                    }
                }
            });

            // Viewer receives Fight Answer
            getFightAns((accepted) => {
                if (role === 'VIEWER') {
                    if (accepted) {
                        isFighting = true;
                        fightBtn.style.display = 'none'; // Hide button once fighting
                    } else {
                        fightBtn.innerText = "FIGHT";
                        fightBtn.disabled = false;
                        alert("Host declined.");
                    }
                }
            });

            // HEARTBEAT
            getHeartbeat((data) => {
                lastHeartbeat = Date.now();
                const remoteHostId = data; 
                if (role !== 'HOST') {
                    if (role !== 'VIEWER') {
                        role = 'VIEWER';
                        updateStatus();
                    }
                } else if (role === 'HOST') {
                    if (remoteHostId > myHostId) {
                        role = 'VIEWER';
                        isFighting = false; // Reset fight on role change
                        updateStatus();
                    }
                }
            });

            // DATA: HOST SWARM (Received by Viewer)
            getSwarmData((data) => {
                if (role === 'VIEWER') {
                    if (!Array.isArray(data) || data.length < 2) return;
                    targetHost.x = data[0];
                    targetHost.y = data[1];
                    let pIndex = 0;
                    for (let i = 2; i < data.length; i += 2) {
                        if (particlesHost[pIndex]) {
                            particlesHost[pIndex].serverPos.x = data[i];
                            particlesHost[pIndex].serverPos.y = data[i+1];
                        }
                        pIndex++;
                    }
                }
            });

            // DATA: VIEWER SWARM (Received by Host)
            getSwarmData2((data) => {
                if (role === 'HOST' && isFighting) {
                    if (!Array.isArray(data) || data.length < 2) return;
                    targetViewer.x = data[0];
                    targetViewer.y = data[1];
                    let pIndex = 0;
                    for (let i = 2; i < data.length; i += 2) {
                        if (particlesViewer[pIndex]) {
                            particlesViewer[pIndex].serverPos.x = data[i];
                            particlesViewer[pIndex].serverPos.y = data[i+1];
                        }
                        pIndex++;
                    }
                }
            });

            // BROADCAST LOOP
            const transmissionInterval = 1000 / TRANSMISSION_RATE;

            setInterval(() => {
                const now = Date.now();

                // Host takeover check
                if (role !== 'HOST' && (now - lastHeartbeat > 2000)) {
                    role = 'HOST';
                    isFighting = false; // Reset fight if connection lost
                    updateStatus();
                }

                if (role === 'HOST') {
                    sendHeartbeat(myHostId); 
                    
                    // Broadcast Host Swarm
                    const payload = [Math.round(targetHost.x), Math.round(targetHost.y)];
                    for (let i = 0; i < particlesHost.length; i++) {
                        payload.push(
                            Math.round(particlesHost[i].position.x * 10) / 10, 
                            Math.round(particlesHost[i].position.y * 10) / 10
                        );
                    }
                    sendSwarmData(payload);
                }
                
                // If I am a fighting Viewer, Broadcast My Swarm
                if (role === 'VIEWER' && isFighting) {
                    const payload = [Math.round(targetViewer.x), Math.round(targetViewer.y)];
                    for (let i = 0; i < particlesViewer.length; i++) {
                        payload.push(
                            Math.round(particlesViewer[i].position.x * 10) / 10, 
                            Math.round(particlesViewer[i].position.y * 10) / 10
                        );
                    }
                    sendSwarmData2(payload);
                }

            }, transmissionInterval); 
        }

        function updateTargetLocal(clientX, clientY) {
            const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
            const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
            let tx = (clientX - offsetX) / scale;
            let ty = (clientY - offsetY) / scale;

            if (role === 'HOST') {
                targetHost.x = tx;
                targetHost.y = ty;
            } else if (role === 'VIEWER' && isFighting) {
                targetViewer.x = tx;
                targetViewer.y = ty;
            }
        }

        window.addEventListener('mousemove', e => updateTargetLocal(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        window.addEventListener('touchstart', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        window.addEventListener('resize', resize);

        function updateStatus() {
            const statusText = document.getElementById('status-text');
            const peerText = document.getElementById('peer-count');
            const fightBtn = document.getElementById('fight-btn');

            peerText.innerText = peers;

            if (role === 'HOST') {
                statusText.innerText = 'HOST';
                statusText.className = 'text-green-600 font-bold';
                fightBtn.style.display = 'none';
            } else if (role === 'VIEWER') {
                statusText.innerText = 'VIEWER';
                statusText.className = 'text-blue-600 font-bold';
                // Only show fight button if not already fighting
                fightBtn.style.display = isFighting ? 'none' : 'inline-block';
            } else {
                statusText.innerText = 'SEARCHING...';
                statusText.className = 'text-gray-500';
                fightBtn.style.display = 'none';
            }
        }

        initSimulation();
        setupNetwork();
        animate();
    </script>
</body>
</html>
