<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>P2P Pixel Swarm (Synced)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- Trystero P2P Library -->
    <script type="module">
        import { joinRoom } from 'https://cdn.skypack.dev/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>

    <style>
        .font-pixel { font-family: 'VT323', monospace; letter-spacing: 0.1em; }
        
        html, body { 
            margin: 0; padding: 0; height: 100%; width: 100%; 
            overflow: hidden; background-color: #f0f0f0; color: #111;
            touch-action: none; 
        }
        
        canvas { display: block; image-rendering: pixelated; }

        /* UI Overlay */
        #ui-layer { position: absolute; top: 1rem; right: 1rem; pointer-events: none; text-align: right; }
        .status-box { 
            background: #fff; 
            border: 2px solid #000; 
            box-shadow: 4px 4px 0px #000;
            padding: 10px 15px; 
            display: inline-block; 
            pointer-events: auto; 
        }
    </style>
</head>
<body class="font-pixel">

    <div id="ui-layer">
        <div class="status-box">
            <h1 class="text-xl uppercase border-b-2 border-black mb-1">Swarm Sync</h1>
            <p>STATUS: <span id="status-text" class="text-blue-600">CONNECTING...</span></p>
            <p>PEERS: <span id="peer-count">0</span></p>
            <p class="text-sm text-gray-500 mt-2" id="controls-hint">Wait...</p>
        </div>
    </div>

    <canvas id="swarmCanvas"></canvas>

    <script type="module">
        // --- 1. CONFIGURATION ---
        const LOGICAL_SIZE = 1000; 
        const NUM_PARTICLES = 400; 
        const PARTICLE_SIZE = 3; 
        const MAX_SPEED = 1.8; 
        const MAX_FORCE = 0.05; 

        const PERCEPTION_RADIUS = 50; 
        const SEPARATION_DISTANCE = 25; 
        const SEPARATION_FACTOR = 1.2; 
        const ALIGNMENT_FACTOR = 0.6;  
        const COHESION_FACTOR = 0.45;
        
        const DENSITY_HIGH_THRESHOLD = 15;
        const DENSITY_LOW_THRESHOLD = 3;
        const TARGET_SEEK_FACTOR = 0.5; 

        const PERCEPTION_RADIUS_SQ = PERCEPTION_RADIUS * PERCEPTION_RADIUS;
        const SEPARATION_DISTANCE_SQ = SEPARATION_DISTANCE * SEPARATION_DISTANCE;
        const SEEK_ACTIVATION_SQ = 100 * 100;

        // --- 2. SEEDED RANDOM ---
        function sfc32(a, b, c, d) {
            return function() {
                a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
                var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21) | d; d = d + 1 | 0;
                t = t + d | 0; c = c + t | 0; return (t >>> 0) / 4294967296;
            }
        }
        const rng = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, 1337);

        // --- 3. MATH CLASSES ---
        class Vector {
            constructor(x, y) { this.x = x || 0; this.y = y || 0; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            magSq() { return this.x * this.x + this.y * this.y; }
            mag() { return Math.sqrt(this.magSq()); }
            normalize() {
                let m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }
            setMag(m) { return this.normalize().mult(m); }
            limit(max) {
                if (this.magSq() > max * max) { this.setMag(max); }
                return this;
            }
            set(x, y) { this.x = x; this.y = y; return this; }
        }

        class Particle {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
                this.acceleration = new Vector(0, 0);
                
                this._steer = new Vector(0,0);
                this._desired = new Vector(0,0);

                // FOR VIEWERS: The position the server says we should be at
                this.serverPos = new Vector(x, y); 
            }

            applyForce(force) {
                this.acceleration.add(force);
            }

            applySteerBehavior(targetX, targetY, factor) {
                this._desired.set(targetX, targetY);
                this._desired.sub(this.position);
                this._desired.setMag(MAX_SPEED);
                
                this._steer.set(this._desired.x, this._desired.y);
                this._steer.sub(this.velocity);
                this._steer.limit(MAX_FORCE * factor);
                
                this.applyForce(this._steer);
            }

            applyBehaviors(particles, target) {
                let sepX = 0, sepY = 0, countSep = 0;
                let aliX = 0, aliY = 0;
                let cohX = 0, cohY = 0, countCoh = 0;

                const px = this.position.x;
                const py = this.position.y;

                for (let i = 0; i < particles.length; i++) {
                    const other = particles[i];
                    if (other === this) continue;

                    const dx = px - other.position.x;
                    const dy = py - other.position.y;
                    const dSq = dx*dx + dy*dy;

                    if (dSq > 0 && dSq < PERCEPTION_RADIUS_SQ) {
                        if (dSq < SEPARATION_DISTANCE_SQ) {
                            const dist = Math.sqrt(dSq);
                            sepX += (dx / dist) / dist; 
                            sepY += (dy / dist) / dist;
                            countSep++;
                        }
                        aliX += other.velocity.x;
                        aliY += other.velocity.y;
                        cohX += other.position.x;
                        cohY += other.position.y;
                        countCoh++;
                    }
                }

                if (countSep > 0) {
                    sepX /= countSep; sepY /= countSep;
                    const sepMag = Math.sqrt(sepX*sepX + sepY*sepY);
                    if (sepMag > 0) {
                        sepX = (sepX / sepMag) * MAX_SPEED;
                        sepY = (sepY / sepMag) * MAX_SPEED;
                    }
                    let steerX = sepX - this.velocity.x;
                    let steerY = sepY - this.velocity.y;
                    const steerSq = steerX*steerX + steerY*steerY;
                    const limitSq = (MAX_FORCE * SEPARATION_FACTOR) ** 2;
                    if (steerSq > limitSq) {
                        const mult = (MAX_FORCE * SEPARATION_FACTOR) / Math.sqrt(steerSq);
                        steerX *= mult;
                        steerY *= mult;
                    }
                    this.acceleration.x += steerX;
                    this.acceleration.y += steerY;
                }

                if (countCoh > 0) {
                    aliX /= countCoh; aliY /= countCoh;
                    const aliMag = Math.sqrt(aliX*aliX + aliY*aliY);
                    if (aliMag > 0) {
                        aliX = (aliX / aliMag) * MAX_SPEED;
                        aliY = (aliY / aliMag) * MAX_SPEED;
                    }
                    let aliSteerX = aliX - this.velocity.x;
                    let aliSteerY = aliY - this.velocity.y;
                    const aliLimitSq = (MAX_FORCE * ALIGNMENT_FACTOR) ** 2;
                    const aliSteerMagSq = aliSteerX*aliSteerX + aliSteerY*aliSteerY;
                    if (aliSteerMagSq > aliLimitSq) {
                        const mult = (MAX_FORCE * ALIGNMENT_FACTOR) / Math.sqrt(aliSteerMagSq);
                        aliSteerX *= mult;
                        aliSteerY *= mult;
                    }
                    this.acceleration.x += aliSteerX;
                    this.acceleration.y += aliSteerY;

                    cohX /= countCoh; cohY /= countCoh;
                    let dynamicFactor = COHESION_FACTOR;
                    
                    if (countCoh > DENSITY_HIGH_THRESHOLD) {
                        dynamicFactor *= 0.5;
                    } else if (countCoh <= DENSITY_LOW_THRESHOLD) {
                        dynamicFactor *= 1.3;
                    }
                    this.applySteerBehavior(cohX, cohY, dynamicFactor);
                }

                const dResX = target.x - px;
                const dResY = target.y - py;
                if ((dResX*dResX + dResY*dResY) > SEEK_ACTIVATION_SQ) {
                    this.applySteerBehavior(target.x, target.y, TARGET_SEEK_FACTOR);
                }
            }

            // HOST uses this
            update() {
                this.velocity.add(this.acceleration);
                this.velocity.limit(MAX_SPEED);
                this.position.add(this.velocity);
                this.acceleration.mult(0);
            }

            // VIEWER uses this (Interpolation)
            updateViewer() {
                // Lerp towards the server position
                // 0.15 is the smoothing factor (approx 15% distance per frame)
                // This makes it slide smoothly even if data only comes 12 times a second
                const lerpFactor = 0.15; 
                this.position.x += (this.serverPos.x - this.position.x) * lerpFactor;
                this.position.y += (this.serverPos.y - this.position.y) * lerpFactor;
            }

            draw(ctx) {
                ctx.fillRect(this.position.x, this.position.y, PARTICLE_SIZE, PARTICLE_SIZE);
            }
        }

        // --- 4. ENGINE & SYNC ---
        
        const canvas = document.getElementById('swarmCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let displayWidth, displayHeight;
        let scale = 1;
        let particles = [];
        let target = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 }; 
        
        // Networking State
        let role = 'WAITING';
        let peers = 0;
        let lastHeartbeat = 0;

        function resize() {
            displayWidth = window.innerWidth;
            displayHeight = window.innerHeight;
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            scale = Math.min(displayWidth / LOGICAL_SIZE, displayHeight / LOGICAL_SIZE);
        }

        function initSimulation() {
            resize();
            if (particles.length === 0) {
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    particles.push(new Particle(rng() * LOGICAL_SIZE, rng() * LOGICAL_SIZE));
                }
            }
        }

        function animate() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            ctx.save();
            const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
            const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);

            ctx.fillStyle = '#ff0000';
            ctx.fillRect(target.x - 2, target.y - 2, 4, 4);

            ctx.fillStyle = '#000000'; 
            
            // --- MAIN LOOP DIFFERENCE BY ROLE ---
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                
                if (role === 'HOST') {
                    // Host runs the physics
                    p.applyBehaviors(particles, target);
                    p.update();
                } else {
                    // Viewer just interpolates to what Host sent
                    p.updateViewer();
                }
                
                p.draw(ctx);
            }

            ctx.restore();
            requestAnimationFrame(animate);
        }

        // --- NETWORKING LOGIC ---
        
        // >>> EDIT TIME HERE <<< 
        const TRANSMISSION_RATE = 12; // Times per second (Hz)
        // >>> END EDIT <<<

        function setupNetwork() {
            const room = window.joinRoom({ appId: 'pixel_swarm_sim_v2_exact' }, 'swarm_room_B');
            
            const [sendHeartbeat, getHeartbeat] = room.makeAction('hb');
            const [sendSwarmData, getSwarmData] = room.makeAction('sd'); // 'sd' = Swarm Data

            room.onPeerJoin(() => { peers++; updateStatus(); });
            room.onPeerLeave(() => { peers--; updateStatus(); });

            getHeartbeat((data) => {
                lastHeartbeat = Date.now();
                if (role !== 'VIEWER') {
                    role = 'VIEWER';
                    updateStatus();
                }
            });

            // RECEIVE SWARM DATA (VIEWER SIDE)
            getSwarmData((data) => {
                if (role === 'VIEWER') {
                    // data is a flat array [tx, ty, x1, y1, x2, y2...]
                    // First 2 numbers are the red target cursor
                    target.x = data[0];
                    target.y = data[1];

                    // The rest are particles
                    let pIndex = 0;
                    // Start reading from index 2
                    for (let i = 2; i < data.length; i += 2) {
                        if (particles[pIndex]) {
                            // Update the "Server Position" target for interpolation
                            particles[pIndex].serverPos.x = data[i];
                            particles[pIndex].serverPos.y = data[i+1];
                        }
                        pIndex++;
                    }
                }
            });

            // TRANSMISSION LOOP
            const transmissionInterval = 1000 / TRANSMISSION_RATE;

            setInterval(() => {
                const now = Date.now();

                if (role !== 'HOST' && (now - lastHeartbeat > 2000)) {
                    role = 'HOST';
                    updateStatus();
                }

                // BROADCAST SWARM DATA (HOST SIDE)
                if (role === 'HOST') {
                    sendHeartbeat(1); 
                    
                    // Create a flat array to save bandwidth: [TargetX, TargetY, P1x, P1y, P2x, P2y...]
                    const payload = new Float32Array(2 + (particles.length * 2));
                    
                    // Add Target cursor first
                    payload[0] = Math.round(target.x);
                    payload[1] = Math.round(target.y);

                    // Add all particles
                    for (let i = 0; i < particles.length; i++) {
                        const p = particles[i];
                        const idx = 2 + (i * 2);
                        // Rounding for bandwidth, or raw float for precision. 
                        // Using raw float here for smoothness.
                        payload[idx] = p.position.x; 
                        payload[idx+1] = p.position.y;
                    }
                    
                    sendSwarmData(payload);
                }
            }, transmissionInterval); 
        }

        function updateTargetLocal(clientX, clientY) {
            if (role === 'HOST') {
                const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
                const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
                let tx = (clientX - offsetX) / scale;
                let ty = (clientY - offsetY) / scale;
                target.x = tx;
                target.y = ty;
            }
        }

        window.addEventListener('mousemove', e => updateTargetLocal(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        window.addEventListener('touchstart', e => {
             e.preventDefault();
             updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        window.addEventListener('resize', resize);

        function updateStatus() {
            const statusText = document.getElementById('status-text');
            const peerText = document.getElementById('peer-count');
            const hint = document.getElementById('controls-hint');

            peerText.innerText = peers;

            if (role === 'HOST') {
                statusText.innerText = 'HOST';
                statusText.className = 'text-green-600 font-bold';
                hint.innerText = "Simulating physics & Broadcasting.";
            } else if (role === 'VIEWER') {
                statusText.innerText = 'VIEWER';
                statusText.className = 'text-blue-600 font-bold';
                hint.innerText = "Receiving exact positions.";
            } else {
                statusText.innerText = 'SEARCHING...';
            }
        }

        initSimulation();
        setupNetwork();
        animate();
    </script>
</body>
</html>
