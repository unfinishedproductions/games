<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>P2P Pixel Swarm (Fluid Duel)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- Trystero P2P Library -->
    <script type="module">
        import { joinRoom } from 'https://cdn.skypack.dev/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>

    <style>
        .font-pixel { font-family: 'VT323', monospace; letter-spacing: 0.1em; }
        
        html, body { 
            margin: 0; padding: 0; height: 100%; width: 100%; 
            overflow: hidden; background-color: #f0f0f0; color: #111;
            touch-action: none; 
        }
        
        canvas { display: block; image-rendering: pixelated; }

        #ui-layer { position: absolute; top: 1rem; right: 1rem; pointer-events: none; text-align: right; }
        
        .status-box { 
            background: #fff; 
            border: 2px solid #000; 
            box-shadow: 4px 4px 0px #000;
            padding: 10px 15px; 
            display: inline-block; 
            pointer-events: auto; 
            margin-bottom: 10px;
        }

        #fight-btn {
            background-color: #3b82f6;
            color: white;
            border: 2px solid #000;
            box-shadow: 4px 4px 0px #000;
            padding: 5px 15px;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            pointer-events: auto;
            display: none; 
            text-transform: uppercase;
        }
        #fight-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px #000; }
        #fight-btn:disabled { background-color: #9ca3af; box-shadow: none; transform: translate(2px, 2px); }
        
        .input-indicator {
            width: 10px; height: 10px; display: inline-block; border-radius: 50%; background: #ccc; margin-left: 5px;
        }
        .input-active { background: #00ff00; box-shadow: 0 0 5px #00ff00; }
    </style>
</head>
<body class="font-pixel">

    <div id="ui-layer">
        <div class="status-box">
            <h1 class="text-xl uppercase border-b-2 border-black mb-1">Swarm Sync</h1>
            <p>STATUS: <span id="status-text" class="text-gray-500">INITIALIZING...</span></p>
            <p>PEERS: <span id="peer-count">0</span></p>
            <p>ALIVE: <span id="drone-count">0</span></p>
            <p>INPUT: <span id="input-status" class="input-indicator"></span></p>
        </div>
        <br>
        <button id="fight-btn">FIGHT</button>
    </div>

    <canvas id="swarmCanvas"></canvas>

    <script type="module">
        // --- CONFIGURATION ---
        const LOGICAL_SIZE = 600; 
        const NUM_PARTICLES = 400; 
        const PARTICLE_SIZE = 4.5; 
        const MAX_SPEED = 1.8; 
        const MAX_FORCE = 0.05; 

        // Physics
        const PERCEPTION_RADIUS = 45; 
        const SEPARATION_DISTANCE = 25; 
        const SEPARATION_FACTOR = 1.2; 
        const ALIGNMENT_FACTOR = 0.6;  
        const COHESION_FACTOR = 0.45;
        const TARGET_SEEK_FACTOR = 0.5; 
        const ENEMY_AVOID_FACTOR = 1.5; 

        // Optimization
        const PERCEPTION_RADIUS_SQ = PERCEPTION_RADIUS * PERCEPTION_RADIUS;
        const SEPARATION_DISTANCE_SQ = SEPARATION_DISTANCE * SEPARATION_DISTANCE;
        const SEEK_ACTIVATION_SQ = 100 * 100;
        const COLLISION_SQ = (PARTICLE_SIZE * 2) ** 2; 

        // Seeded Random
        function sfc32(a, b, c, d) {
            return function() {
                a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
                var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21) | d; d = d + 1 | 0;
                t = t + d | 0; c = c + t | 0; return (t >>> 0) / 4294967296;
            }
        }
        const rng = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, 1337);

        // --- CLASSES ---
        class Vector {
            constructor(x, y) { this.x = x || 0; this.y = y || 0; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            magSq() { return this.x * this.x + this.y * this.y; }
            mag() { return Math.sqrt(this.magSq()); }
            normalize() {
                let m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }
            setMag(m) { return this.normalize().mult(m); }
            limit(max) {
                if (this.magSq() > max * max) { this.setMag(max); }
                return this;
            }
            set(x, y) { this.x = x; this.y = y; return this; }
            copy() { return new Vector(this.x, this.y); }
            dot(v) { return this.x * v.x + this.y * v.y; }
        }

        class Particle {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
                this.acceleration = new Vector(0, 0);
                
                this.serverPos = new Vector(x, y);
                this.colliding = false; 
                this.dead = false; 
                this.isDying = false; 
                this.expansion = 1.0;
            }

            respawn(x, y) {
                this.position.set(x, y);
                this.serverPos.set(x, y);
                this.velocity.set(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
                this.dead = false;
                this.isDying = false;
                this.expansion = 1.0;
            }

            hide() {
                this.dead = true;
                this.isDying = false;
                this.position.set(-9999, -9999);
                this.serverPos.set(-9999, -9999);
            }

            kill() {
                if (this.dead || this.isDying) return;
                this.isDying = true;
                this.velocity.mult(0.2); 
            }

            divert(other) {
                let bounce = new Vector(this.position.x - other.position.x, this.position.y - other.position.y);
                bounce.normalize().mult(MAX_SPEED);
                this.applyForce(bounce);
            }

            applyForce(force) {
                this.acceleration.add(force);
            }

            steerTo(targetX, targetY, factor) {
                let desiredX = targetX - this.position.x;
                let desiredY = targetY - this.position.y;
                const dMag = Math.sqrt(desiredX*desiredX + desiredY*desiredY);
                if (dMag > 0) {
                    desiredX = (desiredX / dMag) * MAX_SPEED;
                    desiredY = (desiredY / dMag) * MAX_SPEED;
                }
                let steerX = desiredX - this.velocity.x;
                let steerY = desiredY - this.velocity.y;
                const steerMagSq = steerX*steerX + steerY*steerY;
                const maxForceSq = (MAX_FORCE * factor) ** 2;
                if (steerMagSq > maxForceSq) {
                    const mul = (MAX_FORCE * factor) / Math.sqrt(steerMagSq);
                    steerX *= mul;
                    steerY *= mul;
                }
                this.acceleration.x += steerX;
                this.acceleration.y += steerY;
            }

            applyBehaviors(particles, target, enemies, bothActive) {
                if (this.dead || this.isDying) return;

                let sepX = 0, sepY = 0, countSep = 0;
                let aliX = 0, aliY = 0;
                let cohX = 0, cohY = 0, countCoh = 0;
                const px = this.position.x;
                const py = this.position.y;

                for (let i = 0; i < particles.length; i++) {
                    const other = particles[i];
                    if (other === this || other.dead || other.isDying) continue;

                    const dx = px - other.position.x;
                    const dy = py - other.position.y;
                    const dSq = dx*dx + dy*dy;

                    if (dSq > 0 && dSq < PERCEPTION_RADIUS_SQ) {
                        const dist = Math.sqrt(dSq);
                        if (dSq < SEPARATION_DISTANCE_SQ) {
                            sepX += (dx / dist) / dist; 
                            sepY += (dy / dist) / dist;
                            countSep++;
                        }
                        aliX += other.velocity.x;
                        aliY += other.velocity.y;
                        cohX += other.position.x;
                        cohY += other.position.y;
                        countCoh++;
                    }
                }

                if (!bothActive && enemies) {
                    let avoX = 0, avoY = 0, countAvo = 0;
                    for (let i = 0; i < enemies.length; i++) {
                        const other = enemies[i];
                        if (other.dead || other.isDying) continue;
                        const dx = px - other.position.x;
                        const dy = py - other.position.y;
                        const dSq = dx*dx + dy*dy;
                        if (dSq > 0 && dSq < PERCEPTION_RADIUS_SQ) {
                            const dist = Math.sqrt(dSq);
                            avoX += (dx / dist) / dist; 
                            avoY += (dy / dist) / dist;
                            countAvo++;
                        }
                    }
                    if (countAvo > 0) {
                        avoX /= countAvo; avoY /= countAvo;
                        const mag = Math.sqrt(avoX*avoX + avoY*avoY);
                        if (mag > 0) { avoX = (avoX/mag) * MAX_SPEED; avoY = (avoY/mag) * MAX_SPEED; }
                        let sX = avoX - this.velocity.x;
                        let sY = avoY - this.velocity.y;
                        const sMagSq = sX*sX + sY*sY;
                        const limSq = (MAX_FORCE * ENEMY_AVOID_FACTOR) ** 2;
                        if (sMagSq > limSq) {
                            const m = (MAX_FORCE * ENEMY_AVOID_FACTOR) / Math.sqrt(sMagSq);
                            sX *= m; sY *= m;
                        }
                        this.acceleration.x += sX;
                        this.acceleration.y += sY;
                    }
                }

                if (countSep > 0) {
                    sepX /= countSep; sepY /= countSep;
                    const mag = Math.sqrt(sepX*sepX + sepY*sepY);
                    if (mag > 0) { sepX = (sepX/mag) * MAX_SPEED; sepY = (sepY/mag) * MAX_SPEED; }
                    let sX = sepX - this.velocity.x;
                    let sY = sepY - this.velocity.y;
                    const sMagSq = sX*sX + sY*sY;
                    const limSq = (MAX_FORCE * SEPARATION_FACTOR) ** 2;
                    if (sMagSq > limSq) {
                        const m = (MAX_FORCE * SEPARATION_FACTOR) / Math.sqrt(sMagSq);
                        sX *= m; sY *= m;
                    }
                    this.acceleration.x += sX;
                    this.acceleration.y += sY;
                }

                if (countCoh > 0) {
                    aliX /= countCoh; aliY /= countCoh;
                    const mag = Math.sqrt(aliX*aliX + aliY*aliY);
                    if (mag > 0) { aliX = (aliX/mag) * MAX_SPEED; aliY = (aliY/mag) * MAX_SPEED; }
                    let sX = aliX - this.velocity.x;
                    let sY = aliY - this.velocity.y;
                    const sMagSq = sX*sX + sY*sY;
                    const limSq = (MAX_FORCE * ALIGNMENT_FACTOR) ** 2;
                    if (sMagSq > limSq) {
                        const m = (MAX_FORCE * ALIGNMENT_FACTOR) / Math.sqrt(sMagSq);
                        sX *= m; sY *= m;
                    }
                    this.acceleration.x += sX;
                    this.acceleration.y += sY;

                    cohX /= countCoh; cohY /= countCoh;
                    let dynamicFactor = COHESION_FACTOR;
                    if (countCoh > 15) dynamicFactor *= 0.7; 
                    else if (countCoh <= 3) dynamicFactor *= 1.3; 
                    this.steerTo(cohX, cohY, dynamicFactor);
                }

                const dResX = target.x - px;
                const dResY = target.y - py;
                if ((dResX*dResX + dResY*dResY) > SEEK_ACTIVATION_SQ) {
                    this.steerTo(target.x, target.y, TARGET_SEEK_FACTOR);
                }
            }

            update() {
                if (this.dead) return; 
                this.velocity.add(this.acceleration);
                this.velocity.limit(MAX_SPEED);
                this.position.add(this.velocity);
                this.acceleration.mult(0);
            }

            updateViewer() {
                // Handle death/respawn from server data
                if (this.serverPos.x < -5000) {
                    if (this.position.x < -5000) {
                        this.dead = true;
                        this.isDying = false;
                        return;
                    }
                    if (!this.dead && !this.isDying) {
                        this.kill(); 
                    }
                    return;
                } 

                if (this.dead || this.isDying) {
                    this.dead = false; 
                    this.isDying = false; 
                    this.expansion = 1.0;
                    this.position.x = this.serverPos.x;
                    this.position.y = this.serverPos.y;
                    this.velocity.set(0,0);
                    return;
                }

                const lerpFactor = 0.2; 
                const dx = this.serverPos.x - this.position.x;
                const dy = this.serverPos.y - this.position.y;
                
                // FIXED: Increased threshold from 2500 to 9000. 
                // This prevents snapping when mobile hosts send data with slight irregularity.
                if (dx*dx + dy*dy > 9000) { 
                    this.position.x = this.serverPos.x;
                    this.position.y = this.serverPos.y;
                    this.velocity.set(0,0); 
                } else {
                    const moveX = dx * lerpFactor;
                    const moveY = dy * lerpFactor;
                    this.velocity.set(moveX, moveY);
                    this.velocity.limit(MAX_SPEED);
                    this.position.add(this.velocity);
                }
            }

            draw(ctx, color) {
                if (this.dead) return;

                if (this.isDying) {
                    this.expansion += 0.2; 
                    const size = PARTICLE_SIZE * this.expansion;
                    const offset = (size - PARTICLE_SIZE) / 2;
                    ctx.fillStyle = '#ff0000'; 
                    ctx.fillRect(this.position.x - offset, this.position.y - offset, size, size);

                    if (this.expansion >= 3.0) {
                        this.hide(); 
                    }
                    return;
                }
                
                ctx.fillStyle = this.colliding ? '#ff0000' : color;
                ctx.fillRect(this.position.x, this.position.y, PARTICLE_SIZE, PARTICLE_SIZE);
            }
        }

        // --- ENGINE ---
        const canvas = document.getElementById('swarmCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let displayWidth, displayHeight;
        let scale = 1;
        
        let particlesHost = []; 
        let particlesViewer = []; 
        
        let targetHost = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 }; 
        let targetViewer = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 };

        let role = 'WAITING';
        let isFighting = false;
        let peers = 0;
        let lastHeartbeat = 0;
        const myHostId = Math.floor(Math.random() * 1000000); 

        // INPUT STATE
        let lastInputTime = 0;
        let myInputActive = false;
        let peerInputActive = false;

        // NETWORK STATE
        // We moved network actions here to access them in animate()
        let netSendHeartbeat, netSendSwarmData, netSendSwarmData2;
        let lastTransmissionTime = 0;

        function resize() {
            displayWidth = window.innerWidth;
            displayHeight = window.innerHeight;
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            scale = Math.min(displayWidth / LOGICAL_SIZE, displayHeight / LOGICAL_SIZE);
        }

        function initSimulation() {
            resize();
            if (particlesHost.length === 0) {
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    particlesHost.push(new Particle(rng() * LOGICAL_SIZE, rng() * LOGICAL_SIZE));
                    const p = new Particle(-9999, -9999);
                    p.hide();
                    particlesViewer.push(p);
                }
            }
        }

        function countAlive(arr) {
            let c = 0;
            for(let i=0; i<arr.length; i++) { if(!arr[i].dead) c++; }
            return c;
        }

        function animate() {
            // Check Input Status
            const now = Date.now();
            if (now - lastInputTime < 500) {
                myInputActive = true;
                document.getElementById('input-status').classList.add('input-active');
            } else {
                myInputActive = false;
                document.getElementById('input-status').classList.remove('input-active');
            }

            // --- NETWORK TRANSMISSION LOOP (MOVED INSIDE ANIMATE FOR MOBILE STABILITY) ---
            // 15 FPS = 66ms interval
            if (now - lastTransmissionTime > 66) {
                lastTransmissionTime = now;

                if (role !== 'HOST' && (now - lastHeartbeat > 15000)) {
                    role = 'HOST';
                    isFighting = false; 
                    updateStatus();
                }

                if (role === 'HOST' && netSendSwarmData) {
                    netSendHeartbeat(myHostId); 
                    const payload = [myInputActive ? 1 : 0, Math.round(targetHost.x), Math.round(targetHost.y)];
                    // Send ALL particles (even dead ones) to ensure array index consistency
                    for (let p of particlesHost) {
                        if (!p.dead && !p.isDying) {
                            payload.push(Math.round(p.position.x), Math.round(p.position.y));
                        } else {
                            payload.push(-9999, -9999);
                        }
                    }
                    netSendSwarmData(payload);
                }
                
                if (role === 'VIEWER' && isFighting && netSendSwarmData2) {
                    const payload = [myInputActive ? 1 : 0, Math.round(targetViewer.x), Math.round(targetViewer.y)];
                    for (let p of particlesViewer) {
                        if (!p.dead && !p.isDying) {
                            payload.push(Math.round(p.position.x), Math.round(p.position.y));
                        } else {
                            payload.push(-9999, -9999);
                        }
                    }
                    netSendSwarmData2(payload);
                }
            }

            // Determine if valid fight
            const hostActive = (role === 'HOST') ? myInputActive : peerInputActive;
            const viewerActive = (role === 'VIEWER') ? myInputActive : peerInputActive;
            const bothActive = hostActive && viewerActive;

            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            ctx.save();
            const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
            const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Bounds
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);

            // Targets
            ctx.fillStyle = hostActive ? '#000000' : '#888888'; 
            ctx.fillRect(targetHost.x - 2, targetHost.y - 2, 4, 4);
            
            if (isFighting) {
                ctx.fillStyle = viewerActive ? '#0000ff' : '#8888ff'; 
                ctx.fillRect(targetViewer.x - 2, targetViewer.y - 2, 4, 4);
            }

            // 1. UPDATE
            if (role === 'HOST') {
                for (let p of particlesHost) {
                    p.applyBehaviors(particlesHost, targetHost, isFighting ? particlesViewer : null, bothActive);
                    p.update();
                    p.colliding = false;
                }
            } else {
                for (let p of particlesHost) {
                    p.updateViewer();
                    p.colliding = false;
                }
            }

            if (role === 'VIEWER' && isFighting) {
                for (let p of particlesViewer) {
                    p.applyBehaviors(particlesViewer, targetViewer, particlesHost, bothActive);
                    p.update();
                    p.colliding = false;
                }
            } else {
                for (let p of particlesViewer) {
                    p.updateViewer();
                    p.colliding = false;
                }
            }

            // 2. COLLISION
            if (isFighting) {
                let p1List, p2List;
                if (role === 'HOST') { p1List = particlesHost; p2List = particlesViewer; }
                else if (role === 'VIEWER') { p1List = particlesViewer; p2List = particlesHost; }

                if (p1List && p2List) {
                    for (let i = 0; i < NUM_PARTICLES; i++) {
                        const pSelf = p1List[i];
                        if (pSelf.dead || pSelf.isDying) continue; 

                        for (let j = 0; j < NUM_PARTICLES; j++) {
                            const pEnemy = p2List[j];
                            if (pEnemy.dead || pEnemy.isDying) continue; 

                            const dx = pSelf.position.x - pEnemy.position.x;
                            if (Math.abs(dx) > 10) continue; 

                            const dy = pSelf.position.y - pEnemy.position.y;
                            if (Math.abs(dy) > 10) continue; 
                            
                            if (dx*dx + dy*dy < COLLISION_SQ) {
                                pSelf.colliding = true;
                                pEnemy.colliding = true; 

                                if (!bothActive) {
                                    pSelf.divert(pEnemy);
                                } else {
                                    // Combat Logic
                                    const v1 = pSelf.velocity.copy();
                                    const v2 = pEnemy.velocity.copy();
                                    const v1n = v1.copy().normalize();
                                    const v2n = v2.copy().normalize();
                                    
                                    const dot = v1n.dot(v2n);

                                    // Rear-end (> 0.4 approx 66 deg)
                                    if (dot > 0.4) {
                                        pSelf.divert(pEnemy); 
                                    } 
                                    // Head-on (< -0.8 approx 143 deg)
                                    else if (dot < -0.8) {
                                        if (pSelf.velocity.magSq() < pEnemy.velocity.magSq()) {
                                            pSelf.kill();
                                            break;
                                        }
                                    } 
                                    // Sideswipe
                                    else {
                                        const colVec = new Vector(pEnemy.position.x - pSelf.position.x, pEnemy.position.y - pSelf.position.y).normalize();
                                        
                                        const myImpact = v1n.dot(colVec);
                                        const enemyImpact = v2n.dot(colVec.mult(-1));

                                        if (enemyImpact > myImpact) {
                                            pSelf.kill();
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 3. DRAW
            for (let p of particlesHost) p.draw(ctx, '#000000');
            if (isFighting) {
                for (let p of particlesViewer) p.draw(ctx, '#0000ff');
            }

            let aliveCount = 0;
            if (role === 'HOST') aliveCount = countAlive(particlesHost);
            else if (role === 'VIEWER') aliveCount = countAlive(particlesViewer);
            document.getElementById('drone-count').innerText = aliveCount;

            ctx.restore();
            requestAnimationFrame(animate);
        }

        // --- NETWORK ---
        function setupNetwork() {
            const room = window.joinRoom({ appId: 'pixel_swarm_sim_v9_optimized' }, 'swarm_room_main');
            
            const [sendHeartbeat, getHeartbeat] = room.makeAction('hb');
            const [sendSwarmData, getSwarmData] = room.makeAction('sd'); 
            const [sendSwarmData2, getSwarmData2] = room.makeAction('sd2'); 
            const [sendFightReq, getFightReq] = room.makeAction('reqFight');
            const [sendFightAns, getFightAns] = room.makeAction('ansFight');

            // Assign to globals so animate() can use them
            netSendHeartbeat = sendHeartbeat;
            netSendSwarmData = sendSwarmData;
            netSendSwarmData2 = sendSwarmData2;

            room.onPeerJoin(() => { peers++; updateStatus(); });
            room.onPeerLeave(() => { peers--; updateStatus(); });

            function syncParticles(targetArray, data) {
                if (!Array.isArray(data) || data.length < 3) return;
                
                peerInputActive = (data[0] === 1);

                if (targetArray === particlesHost) { targetHost.x = data[1]; targetHost.y = data[2]; }
                else { targetViewer.x = data[1]; targetViewer.y = data[2]; }

                let pIndex = 0;
                for (let i = 3; i < data.length; i += 2) {
                    if (pIndex < targetArray.length) {
                        const p = targetArray[pIndex];
                        p.serverPos.x = data[i];
                        p.serverPos.y = data[i+1];
                    }
                    pIndex++;
                }
                
                // IMPORTANT: Since we send -9999 for dead ones, logic is handled in updateViewer
                // No need to explicitly hide tail here as we send full list.
            }

            getSwarmData((data) => {
                if (role === 'VIEWER') syncParticles(particlesHost, data);
            });

            getSwarmData2((data) => {
                if (role === 'HOST' && isFighting) syncParticles(particlesViewer, data);
            });

            const fightBtn = document.getElementById('fight-btn');
            fightBtn.onclick = () => {
                if (role === 'VIEWER') {
                    sendFightReq('FIGHT ME');
                    fightBtn.innerText = "WAITING...";
                    fightBtn.disabled = true;
                }
            };

            getFightReq((data, peerId) => {
                if (role === 'HOST' && !isFighting) {
                    if (confirm("Peer requesting DUEL. Accept?")) {
                        isFighting = true;
                        sendFightAns(true);
                        targetViewer = { x: LOGICAL_SIZE/2, y: 80 };
                        for(let p of particlesViewer) {
                            p.respawn(LOGICAL_SIZE/2 + (rng() * 400 - 200), rng() * 100 - 50);
                        }
                    } else {
                        sendFightAns(false);
                    }
                }
            });

            getFightAns((accepted) => {
                if (role === 'VIEWER') {
                    if (accepted) {
                        isFighting = true;
                        fightBtn.style.display = 'none';
                        targetViewer = { x: LOGICAL_SIZE/2, y: 80 };
                        for(let p of particlesViewer) {
                            p.respawn(LOGICAL_SIZE/2 + (rng() * 400 - 200), rng() * 100 - 50);
                        }
                    } else {
                        fightBtn.innerText = "FIGHT";
                        fightBtn.disabled = false;
                        alert("Host declined.");
                    }
                }
            });

            getHeartbeat((data) => {
                lastHeartbeat = Date.now();
                const remoteHostId = data; 
                if (role !== 'HOST') {
                    if (role !== 'VIEWER') {
                        role = 'VIEWER';
                        updateStatus();
                    }
                } else if (role === 'HOST') {
                    if (remoteHostId > myHostId) {
                        role = 'VIEWER';
                        isFighting = false; 
                        updateStatus();
                    }
                }
            });

            // Note: setInterval is removed here. Transmission logic is now in animate()
        }

        function updateTargetLocal(clientX, clientY) {
            lastInputTime = Date.now(); 
            const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
            const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
            let tx = (clientX - offsetX) / scale;
            let ty = (clientY - offsetY) / scale;

            if (role === 'HOST') {
                targetHost.x = tx;
                targetHost.y = ty;
            } else if (role === 'VIEWER' && isFighting) {
                targetViewer.x = tx;
                targetViewer.y = ty;
            }
        }

        canvas.addEventListener('mousemove', e => updateTargetLocal(e.clientX, e.clientY));
        canvas.addEventListener('touchmove', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        window.addEventListener('resize', resize);

        function updateStatus() {
            const statusText = document.getElementById('status-text');
            const peerText = document.getElementById('peer-count');
            const fightBtn = document.getElementById('fight-btn');

            peerText.innerText = peers;

            if (role === 'HOST') {
                statusText.innerText = 'HOST';
                statusText.className = 'text-green-600 font-bold';
                fightBtn.style.display = 'none';
            } else if (role === 'VIEWER') {
                statusText.innerText = 'VIEWER';
                statusText.className = 'text-blue-600 font-bold';
                fightBtn.style.display = isFighting ? 'none' : 'inline-block';
            } else {
                statusText.innerText = 'SEARCHING...';
                statusText.className = 'text-gray-500';
                fightBtn.style.display = 'none';
            }
        }

        initSimulation();
        setupNetwork();
        animate();
    </script>
</body>
</html>
