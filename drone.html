<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Drone</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <script>
        (function() {
            window.triggerGC = function() {
                queueMicrotask(() => { 
                    try {
                        let img = document.createElement("img");
                        img.src = window.URL.createObjectURL(new Blob([new ArrayBuffer(5e+7)])); 
                        img.onerror = function() {
                            window.URL.revokeObjectURL(this.src);
                            img = null;
                        }
                    } catch(e) {}
                });
            };

            const OriginalRTCPeerConnection = window.RTCPeerConnection;
            const activeConnections = new Set();

            window.RTCPeerConnection = function(...args) {
                const pc = new OriginalRTCPeerConnection(...args);
                activeConnections.add(pc);
                const originalClose = pc.close.bind(pc);
                pc.close = function() {
                    if (pc.signalingState !== 'closed') originalClose();
                    activeConnections.delete(pc);
                };
                return pc;
            };

            window.RTCPeerConnection.prototype = OriginalRTCPeerConnection.prototype;
            Object.keys(OriginalRTCPeerConnection).forEach(prop => {
                window.RTCPeerConnection[prop] = OriginalRTCPeerConnection[prop];
            });

            window.addEventListener('beforeunload', () => {
                activeConnections.forEach(pc => pc.close());
                activeConnections.clear();
            });
        })();
    </script>

    <script type="module">
        import { joinRoom } from 'https://cdn.skypack.dev/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>

<style>
    body { 
        margin: 0; padding: 0; height: 100%; width: 100%; 
        overflow: hidden; background-color: #f0f0f0; color: #111;
        touch-action: none; 
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        font-weight: bold;
    }
    
    canvas { display: block; image-rendering: pixelated; }

    #ui-layer { 
        position: absolute; 
        top: 0; left: 0; 
        width: 100%; 
        padding: 1.5rem; 
        display: flex; 
        justify-content: space-between; 
        align-items: flex-start;
        pointer-events: none; 
        z-index: 10;
    }

    .ui-element {
        pointer-events: auto;
    }

    #fight-btn {
        background-color: #111;
        color: white;
        border: none;
        padding: 8px 24px;
        font-size: 1.25rem;
        font-weight: 800;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        display: none; 
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        transition: transform 0.1s;
    }
    #fight-btn:active { transform: scale(0.95); }
    
    #enemy-stats { display: none; color: #0000ff; }
</style>
</head>
<body>

<div id="ui-layer">
    <div class="ui-element text-2xl">
        <span id="my-count">400</span>
    </div>
    <div class="ui-element text-2xl text-right">
        <button id="fight-btn">FIGHT</button>
        <div id="enemy-stats"><span id="enemy-count">400</span></div>
    </div>
</div>

<canvas id="swarmCanvas"></canvas>

<script type="module">
    // --- CONFIGURATION ---
    const LOGICAL_SIZE = 600; 
    const NUM_PARTICLES = 400; 
    const PARTICLE_SIZE = 4.5; 
    const MAX_SPEED = 1.8; 
    const MAX_FORCE = 0.05; 

    // Physics
    const PERCEPTION_RADIUS = 45; 
    const SEPARATION_DISTANCE = 25; 
    const SEPARATION_FACTOR = 1.2; 
    const ALIGNMENT_FACTOR = 0.6;  
    const COHESION_FACTOR = 0.45;
    const TARGET_SEEK_FACTOR = 0.5; 
    const ENEMY_AVOID_FACTOR = 2.0; 

    const PERCEPTION_RADIUS_SQ = PERCEPTION_RADIUS * PERCEPTION_RADIUS;
    const SEPARATION_DISTANCE_SQ = SEPARATION_DISTANCE * SEPARATION_DISTANCE;
    const SEEK_ACTIVATION_SQ = 100 * 100;
    const COLLISION_SQ = (PARTICLE_SIZE * 2) ** 2; 

    // DENSITY LOGIC
    const DENSITY_THRESHOLD = 12; // Neighbors required to feel crushed
    const TIME_TO_CONVERT = 180;  // Frames (approx 3s)

    function sfc32(a, b, c, d) {
        return function() {
            a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
            var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21) | d; d = d + 1 | 0;
            t = t + d | 0; c = c + t | 0; return (t >>> 0) / 4294967296;
        }
    }
    const rng = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, 1337);

    // --- CLASSES ---
    class Vector {
        constructor(x, y) { this.x = x || 0; this.y = y || 0; }
        add(v) { this.x += v.x; this.y += v.y; return this; }
        sub(v) { this.x -= v.x; this.y -= v.y; return this; }
        mult(n) { this.x *= n; this.y *= n; return this; }
        div(n) { this.x /= n; this.y /= n; return this; }
        magSq() { return this.x * this.x + this.y * this.y; }
        mag() { return Math.sqrt(this.magSq()); }
        normalize() {
            let m = this.mag();
            if (m > 0) this.div(m);
            return this;
        }
        setMag(m) { return this.normalize().mult(m); }
        limit(max) {
            if (this.magSq() > max * max) { this.setMag(max); }
            return this;
        }
        set(x, y) { this.x = x; this.y = y; return this; }
        copy() { return new Vector(this.x, this.y); }
        dot(v) { return this.x * v.x + this.y * v.y; }
    }

    class Particle {
        constructor(x, y) {
            this.position = new Vector(x, y);
            this.velocity = new Vector(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
            this.acceleration = new Vector(0, 0);
            this.serverPos = new Vector(x, y);
            this.colliding = false; 
            this.dead = false; 
            this.isDying = false; 
            this.expansion = 1.0;
            
            // LOGIC: Traitors
            this.isTraitor = false;
            this.compressionTimer = 0;
        }

        respawn(x, y) {
            this.position.set(x, y);
            this.serverPos.set(x, y);
            this.velocity.set(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
            this.acceleration.mult(0);
            this.dead = false;
            this.isDying = false;
            this.expansion = 1.0;
            this.isTraitor = false;
            this.compressionTimer = 0;
        }

        hide() {
            this.dead = true;
            this.isDying = false;
            this.position.set(-9999, -9999);
            this.serverPos.set(-9999, -9999);
        }

        kill() {
            if (this.dead || this.isDying || this.isTraitor) return; // Traitors don't die, they surrendered
            this.isDying = true;
            this.velocity.mult(0.2); 
        }

        divert(other) {
            let bounce = new Vector(this.position.x - other.position.x, this.position.y - other.position.y);
            bounce.normalize().mult(MAX_SPEED);
            this.applyForce(bounce);
        }

        applyForce(force) {
            this.acceleration.add(force);
        }

        steerTo(targetX, targetY, factor) {
            let desiredX = targetX - this.position.x;
            let desiredY = targetY - this.position.y;
            const dMag = Math.sqrt(desiredX*desiredX + desiredY*desiredY);
            if (dMag > 0) {
                desiredX = (desiredX / dMag) * MAX_SPEED;
                desiredY = (desiredY / dMag) * MAX_SPEED;
            }
            let steerX = desiredX - this.velocity.x;
            let steerY = desiredY - this.velocity.y;
            const steerMagSq = steerX*steerX + steerY*steerY;
            const maxForceSq = (MAX_FORCE * factor) ** 2;
            if (steerMagSq > maxForceSq) {
                const mul = (MAX_FORCE * factor) / Math.sqrt(steerMagSq);
                steerX *= mul;
                steerY *= mul;
            }
            this.acceleration.x += steerX;
            this.acceleration.y += steerY;
        }

        applyBehaviors(particles, myTarget, enemyTarget, enemies, fighting, bothActive) {
            if (this.dead || this.isDying) return;

            // TRAITOR BEHAVIOR
            // If I turned traitor, I follow the enemy cursor and ignore team rules
            if (this.isTraitor) {
                this.steerTo(enemyTarget.x, enemyTarget.y, TARGET_SEEK_FACTOR);
                // Simple separation so they don't stack infinitely
                let sepX = 0, sepY = 0, countSep = 0;
                for (let other of particles) {
                    if (other === this || other.dead) continue;
                    let dx = this.position.x - other.position.x;
                    let dy = this.position.y - other.position.y;
                    let dSq = dx*dx + dy*dy;
                    if (dSq > 0 && dSq < 100) { // Tiny separation
                         sepX += dx; sepY += dy; countSep++;
                    }
                }
                if (countSep > 0) {
                    this.acceleration.x += (sepX/countSep) * 0.05;
                    this.acceleration.y += (sepY/countSep) * 0.05;
                }
                return; 
            }

            let sepX = 0, sepY = 0, countSep = 0;
            let aliX = 0, aliY = 0;
            let cohX = 0, cohY = 0, countCoh = 0;
            const px = this.position.x;
            const py = this.position.y;

            // 1. DENSITY CHECK (Am I being crushed?)
            for (let i = 0; i < particles.length; i++) {
                const other = particles[i];
                if (other === this || other.dead || other.isDying) continue;

                const dx = px - other.position.x;
                const dy = py - other.position.y;
                const dSq = dx*dx + dy*dy;

                if (dSq > 0 && dSq < PERCEPTION_RADIUS_SQ) {
                    const dist = Math.sqrt(dSq);
                    
                    if (dSq < SEPARATION_DISTANCE_SQ) {
                        sepX += (dx / dist) / dist; 
                        sepY += (dy / dist) / dist;
                        countSep++; // DENSITY COUNTER
                    }
                    aliX += other.velocity.x;
                    aliY += other.velocity.y;
                    cohX += other.position.x;
                    cohY += other.position.y;
                    countCoh++;
                }
            }

            // CHECK COMPRESSION
            if (fighting) {
                if (countSep > DENSITY_THRESHOLD) {
                    this.compressionTimer++;
                    if (this.compressionTimer > TIME_TO_CONVERT) {
                        this.isTraitor = true; // SURRENDER!
                        return;
                    }
                } else {
                    if (this.compressionTimer > 0) this.compressionTimer--;
                }
            }

            // 2. ENEMY AVOIDANCE (Only if loyal)
            if (fighting && enemies && !bothActive) {
                let avoX = 0, avoY = 0, countAvo = 0;
                for (let i = 0; i < enemies.length; i++) {
                    const other = enemies[i];
                    if (other.dead || other.isDying) continue;
                    // If the enemy is a traitor (on their side), they are technically my ally now, ignore them
                    if (other.isTraitor) continue;

                    const dx = px - other.position.x;
                    const dy = py - other.position.y;
                    const dSq = dx*dx + dy*dy;
                    if (dSq > 0 && dSq < PERCEPTION_RADIUS_SQ) {
                        const dist = Math.sqrt(dSq);
                        avoX += (dx / dist) / dist; 
                        avoY += (dy / dist) / dist;
                        countAvo++;
                    }
                }
                if (countAvo > 0) {
                    avoX /= countAvo; avoY /= countAvo;
                    const mag = Math.sqrt(avoX*avoX + avoY*avoY);
                    if (mag > 0) { avoX = (avoX/mag) * MAX_SPEED; avoY = (avoY/mag) * MAX_SPEED; }
                    let sX = avoX - this.velocity.x;
                    let sY = avoY - this.velocity.y;
                    const sMagSq = sX*sX + sY*sY;
                    const limSq = (MAX_FORCE * ENEMY_AVOID_FACTOR) ** 2;
                    if (sMagSq > limSq) {
                        const m = (MAX_FORCE * ENEMY_AVOID_FACTOR) / Math.sqrt(sMagSq);
                        sX *= m; sY *= m;
                    }
                    this.acceleration.x += sX;
                    this.acceleration.y += sY;
                }
            }

            // 3. FLOCKING
            if (countSep > 0) {
                sepX /= countSep; sepY /= countSep;
                const mag = Math.sqrt(sepX*sepX + sepY*sepY);
                if (mag > 0) { sepX = (sepX/mag) * MAX_SPEED; sepY = (sepY/mag) * MAX_SPEED; }
                let sX = sepX - this.velocity.x;
                let sY = sepY - this.velocity.y;
                const sMagSq = sX*sX + sY*sY;
                const limSq = (MAX_FORCE * SEPARATION_FACTOR) ** 2;
                if (sMagSq > limSq) {
                    const m = (MAX_FORCE * SEPARATION_FACTOR) / Math.sqrt(sMagSq);
                    sX *= m; sY *= m;
                }
                this.acceleration.x += sX;
                this.acceleration.y += sY;
            }

            if (countCoh > 0) {
                aliX /= countCoh; aliY /= countCoh;
                const mag = Math.sqrt(aliX*aliX + aliY*aliY);
                if (mag > 0) { aliX = (aliX/mag) * MAX_SPEED; aliY = (aliY/mag) * MAX_SPEED; }
                let sX = aliX - this.velocity.x;
                let sY = aliY - this.velocity.y;
                const sMagSq = sX*sX + sY*sY;
                const limSq = (MAX_FORCE * ALIGNMENT_FACTOR) ** 2;
                if (sMagSq > limSq) {
                    const m = (MAX_FORCE * ALIGNMENT_FACTOR) / Math.sqrt(sMagSq);
                    sX *= m; sY *= m;
                }
                this.acceleration.x += sX;
                this.acceleration.y += sY;

                cohX /= countCoh; cohY /= countCoh;
                let dynamicFactor = COHESION_FACTOR;
                if (countCoh > 15) dynamicFactor *= 0.7; 
                else if (countCoh <= 3) dynamicFactor *= 1.3; 
                this.steerTo(cohX, cohY, dynamicFactor);
            }

            if (hasInteracted) {
                const dResX = myTarget.x - px;
                const dResY = myTarget.y - py;
                if ((dResX*dResX + dResY*dResY) > SEEK_ACTIVATION_SQ) {
                    this.steerTo(myTarget.x, myTarget.y, TARGET_SEEK_FACTOR);
                }
            } else {
                const margin = 50;
                if (px < margin) this.steerTo(LOGICAL_SIZE/2, py, 0.5);
                if (px > LOGICAL_SIZE - margin) this.steerTo(LOGICAL_SIZE/2, py, 0.5);
                if (py < margin) this.steerTo(px, LOGICAL_SIZE/2, 0.5);
                if (py > LOGICAL_SIZE - margin) this.steerTo(px, LOGICAL_SIZE/2, 0.5);
            }
        }

        update() {
            if (this.dead) return; 
            this.velocity.add(this.acceleration);
            this.velocity.limit(MAX_SPEED);
            this.position.add(this.velocity);
            this.acceleration.mult(0);
        }

        updateViewer() {
            // Update positions from network data
            if (this.serverPos.x < -5000) {
                if (this.position.x < -5000) {
                    this.dead = true;
                    this.isDying = false;
                    return;
                }
                if (!this.dead && !this.isDying) {
                    this.kill(); 
                }
                return;
            } 

            if (this.dead || this.isDying) {
                this.dead = false; 
                this.isDying = false; 
                this.expansion = 1.0;
                this.position.x = this.serverPos.x;
                this.position.y = this.serverPos.y;
                this.velocity.set(0,0);
                return;
            }

            const lerpFactor = 0.2; 
            const dx = this.serverPos.x - this.position.x;
            const dy = this.serverPos.y - this.position.y;
            
            if (dx*dx + dy*dy > 25000) { 
                this.position.x = this.serverPos.x;
                this.position.y = this.serverPos.y;
                this.velocity.set(0,0); 
            } else {
                this.position.x += dx * lerpFactor;
                this.position.y += dy * lerpFactor;
                this.velocity.set(dx * lerpFactor, dy * lerpFactor);
                this.velocity.limit(MAX_SPEED);
            }
        }

        draw(ctx, myTeamColor, enemyTeamColor) {
            if (this.dead) return;

            if (this.isDying) {
                this.expansion += 0.2; 
                const size = PARTICLE_SIZE * this.expansion;
                const offset = (size - PARTICLE_SIZE) / 2;
                ctx.fillStyle = '#ff0000'; 
                ctx.fillRect(this.position.x - offset, this.position.y - offset, size, size);

                if (this.expansion >= 3.0) {
                    this.hide(); 
                }
                return;
            }
            
            // COLOR LOGIC FOR SYMMETRIC BETRAYAL
            // If I am Traitor -> Use Enemy Color
            // If I am Loyal -> Use My Team Color
            if (this.isTraitor) {
                ctx.fillStyle = enemyTeamColor;
            } else {
                ctx.fillStyle = this.colliding ? '#ff0000' : myTeamColor;
            }
            
            ctx.fillRect(this.position.x, this.position.y, PARTICLE_SIZE, PARTICLE_SIZE);
        }
    }

    // --- ENGINE ---
    const canvas = document.getElementById('swarmCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    
    let displayWidth, displayHeight;
    let scale = 1;
    
    let particlesHost = []; 
    let particlesViewer = []; 
    
    let targetHost = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 }; 
    let targetViewer = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 };

    let isFighting = false;
    let peers = 0;
    
    let lastInputTime = 0;
    let myInputActive = false;
    let peerInputActive = false;
    
    let hasInteracted = false;

    let netSendHeartbeat, netSendSwarmData, netSendFight, netSendRematch;
    let lastTransmissionTime = 0;

    function resize() {
        displayWidth = window.innerWidth;
        displayHeight = window.innerHeight;
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        scale = Math.min(displayWidth / LOGICAL_SIZE, displayHeight / LOGICAL_SIZE);
    }

    // Respawns particles in the center circle
    function respawnSwarm() {
        for(let p of particlesHost) {
            const angle = rng() * Math.PI * 2;
            const r = Math.sqrt(rng()) * (LOGICAL_SIZE / 4); 
            const x = LOGICAL_SIZE/2 + Math.cos(angle) * r;
            const y = LOGICAL_SIZE/2 + Math.sin(angle) * r;
            p.respawn(x, y);
        }
    }

    function initSimulation() {
        resize();
        if (particlesHost.length === 0) {
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const angle = rng() * Math.PI * 2;
                const r = Math.sqrt(rng()) * (LOGICAL_SIZE / 4); 
                const x = LOGICAL_SIZE/2 + Math.cos(angle) * r;
                const y = LOGICAL_SIZE/2 + Math.sin(angle) * r;
                particlesHost.push(new Particle(x, y));
            }
        }
        if (particlesViewer.length === 0) {
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const p = new Particle(-9999, -9999);
                p.hide();
                particlesViewer.push(p);
            }
        }
    }

    function countAlive(arr) {
        let c = 0;
        for(let i=0; i<arr.length; i++) { if(!arr[i].dead) c++; }
        return c;
    }

    function animate() {
        const now = Date.now();
        
        if (now - lastInputTime < 500) {
            myInputActive = true;
        } else {
            myInputActive = false;
        }

        const bothActive = myInputActive && peerInputActive;
        const myCount = countAlive(particlesHost);
        const enemyCount = countAlive(particlesViewer);

        // UI LOGIC FOR REMATCH
        const fightBtn = document.getElementById('fight-btn');
        const enemyStats = document.getElementById('enemy-stats');
        const enemyCountSpan = document.getElementById('enemy-count');

        if (isFighting) {
            enemyCountSpan.innerText = enemyCount;
            if (myCount === 0 || enemyCount === 0) {
                if (fightBtn.style.display === 'none') {
                    fightBtn.innerText = "REMATCH";
                    fightBtn.style.display = 'block';
                    enemyStats.style.display = 'none';
                }
            } else {
                fightBtn.style.display = 'none';
                enemyStats.style.display = 'block';
            }
        }

        // --- NETWORK ---
        if (now - lastTransmissionTime > 66) {
            lastTransmissionTime = now;
            if (netSendHeartbeat) netSendHeartbeat(1); 

            if (peers > 0 && netSendSwarmData) {
                // PAYLOAD: [Active, tX, tY, p1x, p1y, p1Traitor, p2x, p2y, p2Traitor...]
                const payload = [myInputActive ? 1 : 0, Math.round(targetHost.x), Math.round(targetHost.y)];
                for (let p of particlesHost) {
                    if (!p.dead && !p.isDying) {
                        payload.push(Math.round(p.position.x), Math.round(p.position.y), p.isTraitor ? 1 : 0);
                    } else {
                        payload.push(-9999, -9999, 0);
                    }
                }
                netSendSwarmData(payload);
            }
        }

        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        ctx.save();
        const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
        const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        if (hasInteracted) {
            ctx.fillStyle = myInputActive ? '#000000' : '#888888'; 
            ctx.fillRect(targetHost.x - 2, targetHost.y - 2, 4, 4);
        }
        
        if (peers > 0) {
            if (peerInputActive) {
                ctx.fillStyle = (isFighting ? '#0000ff' : '#aaaaaa');
                ctx.fillRect(targetViewer.x - 2, targetViewer.y - 2, 4, 4);
            }
        }

        // 1. UPDATE HOST PARTICLES
        for (let p of particlesHost) {
            // My particles (Host) check density. If Traitor, they seek ViewerTarget
            p.applyBehaviors(particlesHost, targetHost, targetViewer, isFighting ? particlesViewer : null, isFighting, bothActive);
            p.update();
            p.colliding = false;
        }

        // 2. UPDATE VIEWER PARTICLES (From Network)
        for (let p of particlesViewer) {
            p.updateViewer(); 
            p.colliding = false;
        }

        // 2. COLLISION
        if (isFighting) {
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const pSelf = particlesHost[i];
                // Traitors are invincible (they surrendered)
                if (pSelf.dead || pSelf.isDying || pSelf.isTraitor) continue; 

                for (let j = 0; j < NUM_PARTICLES; j++) {
                    const pEnemy = particlesViewer[j];
                    // Enemy traitors are invincible too
                    if (pEnemy.dead || pEnemy.isDying || pEnemy.isTraitor) continue; 

                    const dx = pSelf.position.x - pEnemy.position.x;
                    if (Math.abs(dx) > 10) continue; 
                    const dy = pSelf.position.y - pEnemy.position.y;
                    if (Math.abs(dy) > 10) continue; 
                    
                    if (dx*dx + dy*dy < COLLISION_SQ) {
                        pSelf.colliding = true;
                        pEnemy.colliding = true; 

                        if (!bothActive) {
                            pSelf.divert(pEnemy);
                        } else {
                            // Standard Collision Logic
                            const v1 = pSelf.velocity.copy();
                            const v2 = pEnemy.velocity.copy();
                            const v1n = v1.copy().normalize();
                            const v2n = v2.copy().normalize();
                            
                            const dot = v1n.dot(v2n);
                            const speedSelfSq = pSelf.velocity.magSq();
                            const speedEnemySq = pEnemy.velocity.magSq();

                            if (dot > 0.5) {
                                if (speedEnemySq > speedSelfSq * 4.0) { pSelf.kill(); break; } 
                                else { pSelf.divert(pEnemy); }
                            } 
                            else if (dot < -0.5) {
                                if (speedSelfSq < speedEnemySq) { pSelf.kill(); break; }
                                else if (Math.abs(speedSelfSq - speedEnemySq) < 0.2) {
                                    if (speedSelfSq > 2.0) { pSelf.kill(); break; } 
                                    else { pSelf.divert(pEnemy); }
                                } else { pSelf.divert(pEnemy); }
                            } 
                            else {
                                if (speedEnemySq > speedSelfSq) { pSelf.kill(); break; } 
                                else { pSelf.divert(pEnemy); }
                            }
                        }
                    }
                }
            }
        }

        // 3. DRAW
        // Host (My) particles: Default Black (#000000), if Traitor -> Blue (#0000ff)
        for (let p of particlesHost) p.draw(ctx, '#000000', '#0000ff');
        
        if (peers > 0) {
            // Viewer (Enemy) particles: Default Blue (#0000ff), if Traitor -> Black (#000000)
            const baseColor = isFighting ? '#0000ff' : '#cccccc';
            for (let p of particlesViewer) p.draw(ctx, baseColor, '#000000');
        }

        document.getElementById('my-count').innerText = myCount;

        ctx.restore();
        requestAnimationFrame(animate);
    }

    // --- NETWORK ---
    function setupNetwork() {
        const room = window.joinRoom({ appId: 'pixel_swarm_sim_v20_final' }, 'swarm_room_main');
        
        const [sendHeartbeat, getHeartbeat] = room.makeAction('hb');
        const [sendSwarmData, getSwarmData] = room.makeAction('sd'); 
        const [sendFight, getFight] = room.makeAction('fightStart');
        const [sendRematch, getRematch] = room.makeAction('rematch');

        netSendHeartbeat = sendHeartbeat;
        netSendSwarmData = sendSwarmData;
        netSendFight = sendFight;
        netSendRematch = sendRematch;

        room.onPeerJoin(() => { peers++; updateStatus(); });
        room.onPeerLeave(() => { 
            peers--; 
            updateStatus(); 
            if(peers <= 0) isFighting = false; 
            if(window.triggerGC) window.triggerGC();
        });

        getSwarmData((data) => {
            if (!Array.isArray(data) || data.length < 3) return;
            peerInputActive = (data[0] === 1);
            targetViewer.x = LOGICAL_SIZE - data[1];
            targetViewer.y = LOGICAL_SIZE - data[2];

            let pIndex = 0;
            // Iterate by 3 now (x, y, traitorStatus)
            for (let i = 3; i < data.length; i += 3) {
                if (pIndex < particlesViewer.length) {
                    const p = particlesViewer[pIndex];
                    const rx = data[i];
                    const ry = data[i+1];
                    const rt = data[i+2]; // Traitor Flag

                    if (rx < -5000) { 
                        p.serverPos.x = -9999; p.serverPos.y = -9999; 
                    } else { 
                        p.serverPos.x = LOGICAL_SIZE - rx; 
                        p.serverPos.y = LOGICAL_SIZE - ry; 
                        p.isTraitor = (rt === 1); // Set Traitor Status from network
                    }
                }
                pIndex++;
            }
        });

        const fightBtn = document.getElementById('fight-btn');
        fightBtn.onclick = () => {
            if (peers > 0) {
                if (fightBtn.innerText === "REMATCH") {
                    respawnSwarm();
                    if(window.triggerGC) window.triggerGC(); 
                    netSendRematch('GO');
                    fightBtn.style.display = 'none';
                    document.getElementById('enemy-stats').style.display = 'block';
                } else {
                    isFighting = true;
                    sendFight('GO');
                    updateStatus();
                }
            }
        };

        getFight((data) => {
            isFighting = true;
            updateStatus();
        });

        getRematch((data) => {
            respawnSwarm();
            if(window.triggerGC) window.triggerGC(); 
            isFighting = true;
        });

        getHeartbeat((data) => {});
    }

    function updateTargetLocal(clientX, clientY) {
        lastInputTime = Date.now(); 
        hasInteracted = true; 
        const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
        const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
        let tx = (clientX - offsetX) / scale;
        let ty = (clientY - offsetY) / scale;
        targetHost.x = tx;
        targetHost.y = ty;
    }

    canvas.addEventListener('mousemove', e => updateTargetLocal(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    canvas.addEventListener('touchstart', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    window.addEventListener('resize', resize);

    function updateStatus() {
        const fightBtn = document.getElementById('fight-btn');
        const enemyStats = document.getElementById('enemy-stats');

        if (peers === 0) {
            fightBtn.style.display = 'none';
            enemyStats.style.display = 'none';
            isFighting = false;
        } else {
            if (isFighting) {
                fightBtn.style.display = 'none';
                enemyStats.style.display = 'block';
            } else {
                fightBtn.innerText = "FIGHT";
                fightBtn.style.display = 'block';
                fightBtn.disabled = false;
                enemyStats.style.display = 'none';
            }
        }
    }

    initSimulation();
    setupNetwork();
    animate();
</script>
</body>
</html>
