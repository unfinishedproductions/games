<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>P2P Pixel Swarm (Fluid Duel)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- Trystero P2P Library -->
    <script type="module">
        import { joinRoom } from 'https://cdn.skypack.dev/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>

    <style>
        .font-pixel { font-family: 'VT323', monospace; letter-spacing: 0.1em; }
        
        html, body { 
            margin: 0; padding: 0; height: 100%; width: 100%; 
            overflow: hidden; background-color: #f0f0f0; color: #111;
            touch-action: none; 
        }
        
        canvas { display: block; image-rendering: pixelated; }

        #ui-layer { position: absolute; top: 1rem; right: 1rem; pointer-events: none; text-align: right; }
        
        .status-box { 
            background: #fff; 
            border: 2px solid #000; 
            box-shadow: 4px 4px 0px #000;
            padding: 10px 15px; 
            display: inline-block; 
            pointer-events: auto; 
            margin-bottom: 10px;
        }

        #fight-btn {
            background-color: #3b82f6;
            color: white;
            border: 2px solid #000;
            box-shadow: 4px 4px 0px #000;
            padding: 5px 15px;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            pointer-events: auto;
            display: none; /* Hidden by default */
            text-transform: uppercase;
        }
        #fight-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px #000; }
        #fight-btn:disabled { background-color: #9ca3af; box-shadow: none; transform: translate(2px, 2px); }
    </style>
</head>
<body class="font-pixel">

    <div id="ui-layer">
        <div class="status-box">
            <h1 class="text-xl uppercase border-b-2 border-black mb-1">Swarm Sync</h1>
            <p>STATUS: <span id="status-text" class="text-gray-500">INITIALIZING...</span></p>
            <p>PEERS: <span id="peer-count">0</span></p>
            <p>ALIVE: <span id="drone-count">0</span></p>
        </div>
        <br>
        <button id="fight-btn">FIGHT</button>
    </div>

    <canvas id="swarmCanvas"></canvas>

    <script type="module">
        // --- CONFIGURATION ---
        // Reduced logical size = Zoomed in camera
        const LOGICAL_SIZE = 600; 
        
        const NUM_PARTICLES = 400; 
        
        // Increased size for visibility
        const PARTICLE_SIZE = 4.5; 
        
        const MAX_SPEED = 1.8; 
        const MAX_FORCE = 0.05; 

        // Physics - Adjusted for the zoomed-in scale
        const PERCEPTION_RADIUS = 45; 
        const SEPARATION_DISTANCE = 25; 
        const SEPARATION_FACTOR = 1.2; 
        const ALIGNMENT_FACTOR = 0.6;  
        const COHESION_FACTOR = 0.45;
        const TARGET_SEEK_FACTOR = 0.5; 
        const DENSITY_HIGH_THRESHOLD = 15;
        const DENSITY_LOW_THRESHOLD = 3;

        // Optimization
        const PERCEPTION_RADIUS_SQ = PERCEPTION_RADIUS * PERCEPTION_RADIUS;
        const SEPARATION_DISTANCE_SQ = SEPARATION_DISTANCE * SEPARATION_DISTANCE;
        const SEEK_ACTIVATION_SQ = 100 * 100;
        const COLLISION_SQ = (PARTICLE_SIZE * 2) ** 2; 

        // Seeded Random
        function sfc32(a, b, c, d) {
            return function() {
                a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
                var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21) | d; d = d + 1 | 0;
                t = t + d | 0; c = c + t | 0; return (t >>> 0) / 4294967296;
            }
        }
        const rng = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, 1337);

        // --- CLASSES ---
        class Vector {
            constructor(x, y) { this.x = x || 0; this.y = y || 0; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            magSq() { return this.x * this.x + this.y * this.y; }
            mag() { return Math.sqrt(this.magSq()); }
            normalize() {
                let m = this.mag();
                if (m > 0) this.div(m);
                return this;
            }
            setMag(m) { return this.normalize().mult(m); }
            limit(max) {
                if (this.magSq() > max * max) { this.setMag(max); }
                return this;
            }
            set(x, y) { this.x = x; this.y = y; return this; }
            copy() { return new Vector(this.x, this.y); }
        }

        class Particle {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
                this.acceleration = new Vector(0, 0);
                
                // Interpolation Target
                this.serverPos = new Vector(x, y);
                this.colliding = false; 
                this.dead = false; 
                
                // Explosion State
                this.isDying = false; 
                this.expansion = 1.0;
            }

            respawn(x, y) {
                this.position.set(x, y);
                this.serverPos.set(x, y);
                this.velocity.set(rng() * 0.4 - 0.2, rng() * 0.4 - 0.2);
                this.dead = false;
                this.isDying = false;
                this.expansion = 1.0;
            }

            kill() {
                if (this.dead || this.isDying) return;
                this.isDying = true;
                this.velocity.mult(0.2); 
            }

            applyForce(force) {
                this.acceleration.add(force);
            }

            // REYNOLDS STEERING: Desired - Velocity
            steerTo(targetX, targetY, factor) {
                let desiredX = targetX - this.position.x;
                let desiredY = targetY - this.position.y;
                
                // Normalize and set to max speed
                const dMag = Math.sqrt(desiredX*desiredX + desiredY*desiredY);
                if (dMag > 0) {
                    desiredX = (desiredX / dMag) * MAX_SPEED;
                    desiredY = (desiredY / dMag) * MAX_SPEED;
                }

                // Steering = Desired - Velocity
                let steerX = desiredX - this.velocity.x;
                let steerY = desiredY - this.velocity.y;

                // Limit force
                const steerMagSq = steerX*steerX + steerY*steerY;
                const maxForceSq = (MAX_FORCE * factor) ** 2;
                
                if (steerMagSq > maxForceSq) {
                    const mul = (MAX_FORCE * factor) / Math.sqrt(steerMagSq);
                    steerX *= mul;
                    steerY *= mul;
                }
                
                this.acceleration.x += steerX;
                this.acceleration.y += steerY;
            }

            // NEW PHYSICS LOGIC (Merged from your preferred sim)
            applyBehaviors(particles, target) {
                if (this.dead || this.isDying) return;

                let sepX = 0, sepY = 0, countSep = 0;
                let aliX = 0, aliY = 0;
                let cohX = 0, cohY = 0, countCoh = 0;
                const px = this.position.x;
                const py = this.position.y;

                // Single loop for performance, but using updated math
                for (let i = 0; i < particles.length; i++) {
                    const other = particles[i];
                    if (other === this || other.dead || other.isDying) continue;

                    const dx = px - other.position.x;
                    const dy = py - other.position.y;
                    const dSq = dx*dx + dy*dy;

                    if (dSq > 0 && dSq < PERCEPTION_RADIUS_SQ) {
                        const dist = Math.sqrt(dSq);
                        
                        // 1. Separation with Inverse Square Law (Stronger repulsion when close)
                        if (dSq < SEPARATION_DISTANCE_SQ) {
                            // Weight by distance (closer = bigger force)
                            sepX += (dx / dist) / dist; 
                            sepY += (dy / dist) / dist;
                            countSep++;
                        }

                        // 2. Alignment & Cohesion Accumulation
                        aliX += other.velocity.x;
                        aliY += other.velocity.y;
                        cohX += other.position.x;
                        cohY += other.position.y;
                        countCoh++;
                    }
                }

                // Apply Separation (Steering)
                if (countSep > 0) {
                    sepX /= countSep; sepY /= countSep;
                    // Normalize to max speed
                    const mag = Math.sqrt(sepX*sepX + sepY*sepY);
                    if (mag > 0) {
                        sepX = (sepX/mag) * MAX_SPEED;
                        sepY = (sepY/mag) * MAX_SPEED;
                    }
                    // Implement Steering: (Desired - Velocity) limited by Force
                    let sX = sepX - this.velocity.x;
                    let sY = sepY - this.velocity.y;
                    const sMagSq = sX*sX + sY*sY;
                    const limSq = (MAX_FORCE * SEPARATION_FACTOR) ** 2;
                    if (sMagSq > limSq) {
                        const m = (MAX_FORCE * SEPARATION_FACTOR) / Math.sqrt(sMagSq);
                        sX *= m; sY *= m;
                    }
                    this.acceleration.x += sX;
                    this.acceleration.y += sY;
                }

                // Apply Alignment (Steering)
                if (countCoh > 0) {
                    aliX /= countCoh; aliY /= countCoh;
                    const mag = Math.sqrt(aliX*aliX + aliY*aliY);
                    if (mag > 0) {
                        aliX = (aliX/mag) * MAX_SPEED;
                        aliY = (aliY/mag) * MAX_SPEED;
                    }
                    let sX = aliX - this.velocity.x;
                    let sY = aliY - this.velocity.y;
                    const sMagSq = sX*sX + sY*sY;
                    const limSq = (MAX_FORCE * ALIGNMENT_FACTOR) ** 2;
                    if (sMagSq > limSq) {
                        const m = (MAX_FORCE * ALIGNMENT_FACTOR) / Math.sqrt(sMagSq);
                        sX *= m; sY *= m;
                    }
                    this.acceleration.x += sX;
                    this.acceleration.y += sY;

                    // Apply Cohesion (Steering) with DYNAMIC FACTOR
                    cohX /= countCoh; cohY /= countCoh;
                    
                    let dynamicFactor = COHESION_FACTOR;
                    // Dynamic breathing logic from your preferred sim
                    if (countCoh > DENSITY_HIGH_THRESHOLD) dynamicFactor *= 0.7; // Crowd? Spread out
                    else if (countCoh <= DENSITY_LOW_THRESHOLD) dynamicFactor *= 1.3; // Lonely? Group up

                    this.steerTo(cohX, cohY, dynamicFactor);
                }

                // Apply Target Seeking (Steering)
                const dResX = target.x - px;
                const dResY = target.y - py;
                if ((dResX*dResX + dResY*dResY) > SEEK_ACTIVATION_SQ) {
                    this.steerTo(target.x, target.y, TARGET_SEEK_FACTOR);
                }
            }

            update() {
                if (this.dead) return; 
                this.velocity.add(this.acceleration);
                this.velocity.limit(MAX_SPEED);
                this.position.add(this.velocity);
                this.acceleration.mult(0);
            }

            // VIEWER INTERPOLATION
            updateViewer() {
                // If server sends to graveyard, trigger local explosion
                if (this.serverPos.x < -5000) {
                    if (!this.dead && !this.isDying) {
                        this.kill(); 
                    }
                    return;
                } 

                // Alive and Normal
                this.dead = false; 
                this.isDying = false; 
                this.expansion = 1.0;

                const lerpFactor = 0.35; 

                const dx = this.serverPos.x - this.position.x;
                const dy = this.serverPos.y - this.position.y;
                
                if (dx*dx + dy*dy > 2500) { 
                    this.position.x = this.serverPos.x;
                    this.position.y = this.serverPos.y;
                    this.velocity.set(0,0); 
                } else {
                    const moveX = dx * lerpFactor;
                    const moveY = dy * lerpFactor;
                    this.velocity.set(moveX, moveY);
                    this.velocity.limit(MAX_SPEED);
                    this.position.x += moveX;
                    this.position.y += moveY;
                }
            }

            draw(ctx, color) {
                if (this.dead) return;

                // --- EXPLOSION ANIMATION ---
                if (this.isDying) {
                    this.expansion += 0.2; 
                    const size = PARTICLE_SIZE * this.expansion;
                    const offset = (size - PARTICLE_SIZE) / 2;
                    ctx.fillStyle = '#ff0000'; 
                    ctx.fillRect(this.position.x - offset, this.position.y - offset, size, size);

                    if (this.expansion >= 3.0) {
                        this.dead = true;
                        this.position.set(-9999, -9999);
                        this.serverPos.set(-9999, -9999); 
                    }
                    return;
                }
                
                ctx.fillStyle = this.colliding ? '#ff0000' : color;
                ctx.fillRect(this.position.x, this.position.y, PARTICLE_SIZE, PARTICLE_SIZE);
            }
        }

        // --- ENGINE ---
        const canvas = document.getElementById('swarmCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let displayWidth, displayHeight;
        let scale = 1;
        
        let particlesHost = []; 
        let particlesViewer = []; 
        
        let targetHost = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 }; 
        let targetViewer = { x: LOGICAL_SIZE/2, y: LOGICAL_SIZE/2 };

        // --- NETWORK STATE ---
        let role = 'WAITING';
        let isFighting = false;
        let peers = 0;
        let lastHeartbeat = 0;
        const myHostId = Math.floor(Math.random() * 1000000); 

        function resize() {
            displayWidth = window.innerWidth;
            displayHeight = window.innerHeight;
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            scale = Math.min(displayWidth / LOGICAL_SIZE, displayHeight / LOGICAL_SIZE);
        }

        function initSimulation() {
            resize();
            if (particlesHost.length === 0) {
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    particlesHost.push(new Particle(rng() * LOGICAL_SIZE, rng() * LOGICAL_SIZE));
                    particlesViewer.push(new Particle(rng() * LOGICAL_SIZE, rng() * LOGICAL_SIZE));
                }
            }
        }

        function countAlive(arr) {
            let c = 0;
            for(let i=0; i<arr.length; i++) { if(!arr[i].dead) c++; }
            return c;
        }

        function animate() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            ctx.save();
            const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
            const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Bounds
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);

            // Targets
            ctx.fillStyle = '#000000'; 
            ctx.fillRect(targetHost.x - 2, targetHost.y - 2, 4, 4);
            
            if (isFighting) {
                ctx.fillStyle = '#0000ff'; 
                ctx.fillRect(targetViewer.x - 2, targetViewer.y - 2, 4, 4);
            }

            // 1. UPDATE LOOPS
            if (role === 'HOST') {
                for (let p of particlesHost) {
                    p.applyBehaviors(particlesHost, targetHost);
                    p.update();
                    p.colliding = false;
                }
            } else {
                for (let p of particlesHost) {
                    p.updateViewer();
                    p.colliding = false;
                }
            }

            if (role === 'VIEWER' && isFighting) {
                for (let p of particlesViewer) {
                    p.applyBehaviors(particlesViewer, targetViewer);
                    p.update();
                    p.colliding = false;
                }
            } else {
                for (let p of particlesViewer) {
                    p.updateViewer();
                    p.colliding = false;
                }
            }

            // 2. COLLISION DETECTION
            if (isFighting) {
                if (role === 'HOST') {
                    for (let i = 0; i < NUM_PARTICLES; i++) {
                        const pH = particlesHost[i];
                        if (pH.dead || pH.isDying) continue; 

                        for (let j = 0; j < NUM_PARTICLES; j++) {
                            const pV = particlesViewer[j];
                            if (pV.dead || pV.isDying) continue; 

                            const dx = pH.position.x - pV.position.x;
                            const dy = pH.position.y - pV.position.y;
                            
                            if (dx*dx + dy*dy < COLLISION_SQ) {
                                pH.colliding = true;
                                pV.colliding = true; 
                                if (pH.velocity.magSq() < pV.velocity.magSq()) {
                                    pH.kill(); 
                                    break; 
                                }
                            }
                        }
                    }
                }

                if (role === 'VIEWER') {
                    for (let i = 0; i < NUM_PARTICLES; i++) {
                        const pV = particlesViewer[i];
                        if (pV.dead || pV.isDying) continue;

                        for (let j = 0; j < NUM_PARTICLES; j++) {
                            const pH = particlesHost[j];
                            if (pH.dead || pH.isDying) continue;

                            const dx = pV.position.x - pH.position.x;
                            const dy = pV.position.y - pH.position.y;
                            
                            if (dx*dx + dy*dy < COLLISION_SQ) {
                                pV.colliding = true;
                                pH.colliding = true;
                                if (pV.velocity.magSq() < pH.velocity.magSq()) {
                                    pV.kill();
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            // 3. DRAW
            for (let p of particlesHost) p.draw(ctx, '#000000');
            if (isFighting) {
                for (let p of particlesViewer) p.draw(ctx, '#0000ff');
            }

            // Update UI count
            let aliveCount = 0;
            if (role === 'HOST') aliveCount = countAlive(particlesHost);
            else if (role === 'VIEWER') aliveCount = countAlive(particlesViewer);
            document.getElementById('drone-count').innerText = aliveCount;

            ctx.restore();
            requestAnimationFrame(animate);
        }

        // --- NETWORKING ---
        const TRANSMISSION_RATE = 15; 

        function setupNetwork() {
            const room = window.joinRoom({ appId: 'pixel_swarm_sim_v6_fluid' }, 'swarm_room_main');
            
            const [sendHeartbeat, getHeartbeat] = room.makeAction('hb');
            const [sendSwarmData, getSwarmData] = room.makeAction('sd'); 
            const [sendSwarmData2, getSwarmData2] = room.makeAction('sd2'); 
            const [sendFightReq, getFightReq] = room.makeAction('reqFight');
            const [sendFightAns, getFightAns] = room.makeAction('ansFight');

            room.onPeerJoin(() => { peers++; updateStatus(); });
            room.onPeerLeave(() => { peers--; updateStatus(); });

            function syncParticles(targetArray, data) {
                if (!Array.isArray(data) || data.length < 2) return;
                
                if (targetArray === particlesHost) { targetHost.x = data[0]; targetHost.y = data[1]; }
                else { targetViewer.x = data[0]; targetViewer.y = data[1]; }

                let pIndex = 0;
                for (let i = 2; i < data.length; i += 2) {
                    if (pIndex < targetArray.length) {
                        const p = targetArray[pIndex];
                        p.serverPos.x = data[i];
                        p.serverPos.y = data[i+1];
                    }
                    pIndex++;
                }
            }

            getSwarmData((data) => {
                if (role === 'VIEWER') syncParticles(particlesHost, data);
            });

            getSwarmData2((data) => {
                if (role === 'HOST' && isFighting) syncParticles(particlesViewer, data);
            });

            const fightBtn = document.getElementById('fight-btn');
            fightBtn.onclick = () => {
                if (role === 'VIEWER') {
                    sendFightReq('FIGHT ME');
                    fightBtn.innerText = "WAITING...";
                    fightBtn.disabled = true;
                }
            };

            getFightReq((data, peerId) => {
                if (role === 'HOST' && !isFighting) {
                    if (confirm("Peer requesting DUEL. Accept?")) {
                        isFighting = true;
                        sendFightAns(true);
                        for(let p of particlesViewer) p.respawn(rng()*LOGICAL_SIZE, rng()*LOGICAL_SIZE);
                    } else {
                        sendFightAns(false);
                    }
                }
            });

            getFightAns((accepted) => {
                if (role === 'VIEWER') {
                    if (accepted) {
                        isFighting = true;
                        fightBtn.style.display = 'none';
                        for(let p of particlesViewer) p.respawn(rng()*LOGICAL_SIZE, rng()*LOGICAL_SIZE);
                    } else {
                        fightBtn.innerText = "FIGHT";
                        fightBtn.disabled = false;
                        alert("Host declined.");
                    }
                }
            });

            getHeartbeat((data) => {
                lastHeartbeat = Date.now();
                const remoteHostId = data; 
                if (role !== 'HOST') {
                    if (role !== 'VIEWER') {
                        role = 'VIEWER';
                        updateStatus();
                    }
                } else if (role === 'HOST') {
                    if (remoteHostId > myHostId) {
                        role = 'VIEWER';
                        isFighting = false; 
                        updateStatus();
                    }
                }
            });

            const transmissionInterval = 1000 / TRANSMISSION_RATE;

            setInterval(() => {
                const now = Date.now();

                if (role !== 'HOST' && (now - lastHeartbeat > 2000)) {
                    role = 'HOST';
                    isFighting = false; 
                    updateStatus();
                }

                if (role === 'HOST') {
                    sendHeartbeat(myHostId); 
                    
                    const payload = [Math.round(targetHost.x), Math.round(targetHost.y)];
                    for (let p of particlesHost) {
                        payload.push(Math.round(p.position.x), Math.round(p.position.y));
                    }
                    sendSwarmData(payload);
                }
                
                if (role === 'VIEWER' && isFighting) {
                    const payload = [Math.round(targetViewer.x), Math.round(targetViewer.y)];
                    for (let p of particlesViewer) {
                        payload.push(Math.round(p.position.x), Math.round(p.position.y));
                    }
                    sendSwarmData2(payload);
                }

            }, transmissionInterval); 
        }

        function updateTargetLocal(clientX, clientY) {
            const offsetX = (displayWidth - LOGICAL_SIZE * scale) / 2;
            const offsetY = (displayHeight - LOGICAL_SIZE * scale) / 2;
            let tx = (clientX - offsetX) / scale;
            let ty = (clientY - offsetY) / scale;

            if (role === 'HOST') {
                targetHost.x = tx;
                targetHost.y = ty;
            } else if (role === 'VIEWER' && isFighting) {
                targetViewer.x = tx;
                targetViewer.y = ty;
            }
        }

        // CORRECTED TOUCH LISTENERS
        canvas.addEventListener('mousemove', e => updateTargetLocal(e.clientX, e.clientY));
        canvas.addEventListener('touchmove', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); updateTargetLocal(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        window.addEventListener('resize', resize);

        function updateStatus() {
            const statusText = document.getElementById('status-text');
            const peerText = document.getElementById('peer-count');
            const fightBtn = document.getElementById('fight-btn');

            peerText.innerText = peers;

            if (role === 'HOST') {
                statusText.innerText = 'HOST';
                statusText.className = 'text-green-600 font-bold';
                fightBtn.style.display = 'none';
            } else if (role === 'VIEWER') {
                statusText.innerText = 'VIEWER';
                statusText.className = 'text-blue-600 font-bold';
                fightBtn.style.display = isFighting ? 'none' : 'inline-block';
            } else {
                statusText.innerText = 'SEARCHING...';
                statusText.className = 'text-gray-500';
                fightBtn.style.display = 'none';
            }
        }

        initSimulation();
        setupNetwork();
        animate();
    </script>
</body>
</html>
