<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pressure Drawing Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f0f0f0;
            font-family: sans-serif;
            touch-action: none; /* Prevent scrolling while drawing */
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Controls */
        .controls {
            background: #333;
            color: white;
            padding: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .btn {
            background: #555;
            border: 1px solid #777;
            color: #ddd;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            flex: 1;
            text-align: center;
            transition: background 0.2s;
        }

        .btn.active {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
            font-weight: bold;
        }

        /* The Canvas */
        #canvas-container {
            flex: 1;
            position: relative;
            cursor: crosshair;
            background: white;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Info HUD */
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            user-select: none;
        }
        
        .clear-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #ef4444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(239, 68, 68, 0.4);
        }
    </style>
</head>
<body>

    <div class="controls">
        <div class="btn active" onclick="setStrategy(1)">1. Squish (Area)</div>
        <div class="btn" onclick="setStrategy(2)">2. Speed (Velo)</div>
        <div class="btn" onclick="setStrategy(3)">3. Flow (Marker)</div>
    </div>

    <div id="canvas-container">
        <div class="hud" id="hud">Mode: Area<br>Val: 0</div>
        <canvas id="drawArea"></canvas>
        <button class="clear-btn" onclick="clearCanvas()">Clear</button>
    </div>

    <script>
        const canvas = document.getElementById('drawArea');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');
        let activeStrategy = 1;

        // Drawing State
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let lastTime = 0;
        let lastWidth = 5; // For smoothing
        
        // Resize canvas to full screen
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function setStrategy(num) {
            activeStrategy = num;
            document.querySelectorAll('.btn').forEach((b, i) => {
                b.classList.toggle('active', i + 1 === num);
            });
            const names = ["Squish (Finger Flattening)", "Velocity (Calligraphy)", "Ink Flow (Time Held)"];
            hud.innerHTML = `Mode: ${names[num-1]}<br>Waiting...`;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // --- MATH HELPERS ---
        function getDistance(x1, y1, x2, y2) {
            return Math.hypot(x2 - x1, y2 - y1);
        }

        // --- MAIN DRAWING LOOP ---
        function handleStart(e) {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches ? e.touches[0] : e;
            lastX = touch.clientX;
            lastY = touch.clientY;
            lastTime = Date.now();
            lastWidth = 5; // Reset width
            
            // Draw a single dot on tap
            drawStroke(touch, 0); 
        }

        function handleMove(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            drawStroke(touch);
        }

        function handleEnd(e) {
            isDrawing = false;
        }

        function drawStroke(touch) {
            const currentX = touch.clientX;
            const currentY = touch.clientY;
            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            const dist = getDistance(lastX, lastY, currentX, currentY);

            let calculatedWidth = 5; // Default
            let debugVal = 0;

            // ==========================================
            // STRATEGY 1: CONTACT AREA (SQUISH)
            // ==========================================
            if (activeStrategy === 1) {
                // radiusX is standard, webkitRadiusX is older Safari
                // Fallback to 20 if hardware returns 0
                let radius = touch.radiusX || touch.webkitRadiusX || 20;
                
                // Normalization: Finger radius usually floats between 15px (light) and 40px (heavy)
                // We map this to a brush size of 2 to 25
                calculatedWidth = (radius - 10) * 1.5; 
                calculatedWidth = Math.max(2, Math.min(calculatedWidth, 30)); // Clamp
                
                debugVal = radius.toFixed(1) + "px";
            }

            // ==========================================
            // STRATEGY 2: VELOCITY (CALLIGRAPHY)
            // ==========================================
            else if (activeStrategy === 2) {
                // Velocity = distance / time
                // Add 1 to time to prevent divide by zero
                let velocity = dist / (deltaTime + 1); 
                
                // Inverse relationship: Fast = Thin, Slow = Thick
                // Base thick = 20, Min thin = 2
                calculatedWidth = 25 / (velocity + 0.5);
                calculatedWidth = Math.max(2, Math.min(calculatedWidth, 25));

                debugVal = velocity.toFixed(2) + " px/ms";
            }

            // ==========================================
            // STRATEGY 3: INK FLOW (TIME ACCUMULATION)
            // ==========================================
            else if (activeStrategy === 3) {
                // If moving very slowly or stopped, width grows
                // If moving fast, width shrinks
                let speed = dist / (deltaTime + 1);
                
                if (speed < 0.5) {
                    // Growing (Holding still)
                    lastWidth += 1; 
                } else {
                    // Shrinking (Moving)
                    lastWidth -= 2; 
                }
                
                calculatedWidth = lastWidth;
                calculatedWidth = Math.max(2, Math.min(calculatedWidth, 40));
                debugVal = "Flow: " + Math.round(calculatedWidth);
            }

            // --- SMOOTHING (LERP) ---
            // Sharp changes in width look ugly. We blend 30% new width with 70% old width.
            const smoothWidth = lastWidth + (calculatedWidth - lastWidth) * 0.2;
            lastWidth = smoothWidth;

            // --- DRAWING ---
            ctx.beginPath();
            
            // Using circles for joints creates smoother variable-width lines than lineJoin
            // Draw a line from last point to current point
            const angle = Math.atan2(currentY - lastY, currentX - lastX);
            const perpX = Math.sin(angle);
            const perpY = Math.cos(angle);

            // This is a simple technique to draw variable width strokes:
            // Just draw circles at the new point. For high-speed (Strategy 2), 
            // you might need to fill the gap with a trapezoid, but for simple JS, 
            // drawing circles closely together works well.
            
            ctx.lineWidth = smoothWidth * 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#000';
            
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();

            // Update State
            lastX = currentX;
            lastY = currentY;
            lastTime = currentTime;
            
            hud.innerHTML = `Mode: ${activeStrategy}<br>Val: ${debugVal}<br>Width: ${smoothWidth.toFixed(1)}`;
        }

        // Event Listeners
        const zone = document.getElementById('canvas-container');
        
        // Touch
        zone.addEventListener('touchstart', handleStart, {passive: false});
        zone.addEventListener('touchmove', handleMove, {passive: false});
        zone.addEventListener('touchend', handleEnd);

        // Mouse (For testing Velocity only - Area/Radius won't work on mouse)
        zone.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

    </script>
</body>
</html>
